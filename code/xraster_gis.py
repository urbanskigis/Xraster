# -*- coding: utf-8 -*-
"""
/***************************************************************************
 XrasterPlug
                                 A QGIS plugin
 Multidimensional raster GIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-08-25
        git sha              : $Format:%H$
        copyright            : (C) 2024 by IO PAN
        email                : jackurbanski@iopan.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from functools import partial

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
from .xraster_gis_dialog import XrasterPlugDialog
import os.path
import os
import xarray as xr
import numpy as np
import math
import pandas as pd
from pandas import Timestamp
from osgeo import gdal
from osgeo import ogr, osr
from matplotlib import pyplot as plt
import importlib.util
import re
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import webbrowser

#gdal.UseExceptions()

# GLOBAL VARIABLE
ppath=''
err_dict = {}
toolER=0
plt.rcParams['figure.figsize']=(8,6)
plt.rcParams.update({'font.size': 8})
figsize=3
fasp=2
fdpi=300
l_c=[]
plt.rcParams['figure.figsize']=(8,6)
plt.rcParams.update({'font.size': 8})
figsize=3
fasp=2
ffont=8
fdpi=300
var_list2=[]
sssL=''




# GLOBAL CONTROL VARIABLES
COORN=0    # number of dimension  3,4
stype=0    # type of data subset ds222
mmask=0    # mask input from file
TABB=0



#-------------------------------------------------------------------------

class XrasterPlug:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'XrasterPlug_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Xraster ')
        
        self.dlg=XrasterPlugDialog()
        
        #  TABS FUNCIONALITY
        # Data tab
        self.dlg.expPLfile.clear()
        self.dlg.ncdataB.clicked.connect(self.select_open_file1)   # INPUT NetCDF data
        self.dlg.maskB.clicked.connect(self.select_open_file2)     # INPUT mask
        self.dlg.resampl.clicked.connect(partial(self.runTOOL,"resampln")) # Change spatial resolution
        self.dlg.areakm2.clicked.connect(partial(self.runTOOL,"areakm")) # LatLong area km2        
        self.dlg.info.clicked.connect(partial(self.runTOOL,"info"))      # NetCDF INFO
        self.dlg.plotMB.clicked.connect(partial(self.runTOOL,"mask_plot")) # PLOT MASK
        
        self.dlg.resetB.clicked.connect(partial(self.runTOOL,"Sreset"))
        self.dlg.selectB.clicked.connect(partial(self.runTOOL,"select"))
        self.dlg.figPlot.clicked.connect(partial(self.runTOOL,"figg")) 
        self.dlg.figReset.clicked.connect(partial(self.runTOOL,"figgr"))
        self.dlg.figEPlot.clicked.connect(partial(self.runTOOL,"figgS"))
        self.dlg.figCSVE.clicked.connect(partial(self.runTOOL,"figgE"))
        self.dlg.SSrun.clicked.connect(partial(self.runTOOL,"ssrun"))
        self.dlg.statPlotB.clicked.connect(partial(self.runTOOL,"stplot"))
        self.dlg.statSavePlot.clicked.connect(partial(self.runTOOL,"stsplot"))
        self.dlg.statPlotBB.clicked.connect(partial(self.runTOOL,"stplotb"))
        self.dlg.ssumPlotB.clicked.connect(partial(self.runTOOL,"ssumplot"))
        self.dlg.statExp.clicked.connect(partial(self.runTOOL,"stexp"))
        self.dlg.EXTrun.clicked.connect(partial(self.runTOOL,"extract"))
        self.dlg.cross_cr.clicked.connect(partial(self.runTOOL,"cross_create"))
        self.dlg.cross_plot.clicked.connect(partial(self.runTOOL,"cross_pplot"))
        self.dlg.cross_plotS.clicked.connect(partial(self.runTOOL,"cross_pplotS"))
        self.dlg.GRrun.clicked.connect(partial(self.runTOOL,"group")) 
        self.dlg.gmapPlot.clicked.connect(partial(self.runTOOL,"gmap")) 
        self.dlg.gtsPlot.clicked.connect(partial(self.runTOOL,"gts")) 
        self.dlg.gmapsPlot.clicked.connect(partial(self.runTOOL,"gmaps"))    
        self.dlg.gmapExp.clicked.connect(partial(self.runTOOL,"gmaptif")) 
        self.dlg.gtssPlot.clicked.connect(partial(self.runTOOL,"gtss")) 
        self.dlg.gtsExp.clicked.connect(partial(self.runTOOL,"gtse")) 
        self.dlg.CreateB.clicked.connect(partial(self.runTOOL,"txtnc")) 
        self.dlg.cjaddB.clicked.connect(partial(self.runTOOL,"add")) 
        self.dlg.cjaddallB.clicked.connect(partial(self.runTOOL,"addall")) 
        self.dlg.cjclearB.clicked.connect(partial(self.runTOOL,"clear")) 
        self.dlg.JoinB.clicked.connect(partial(self.runTOOL,"ncjoin")) 
        self.dlg.SaveB.clicked.connect(partial(self.runTOOL,"ncsave"))  
        self.dlg.pdfButton.clicked.connect(partial(self.runTOOL,"manual"))  
        self.dlg.gisArun.clicked.connect(partial(self.runTOOL,"gis1"))           
        
        self.dlg.expPLfileB.clicked.connect(self.select_output_file1) 
        self.dlg.expMapB.clicked.connect(self.select_output_file2)
        self.dlg.expTSfileB.clicked.connect(self.select_output_file3)
        self.dlg.exportVPfileB.clicked.connect(self.select_output_file4)   

        # Stat tab
        self.dlg.SBssfileB.clicked.connect(self.select_output_file6)
        self.dlg.SBzsfileB.clicked.connect(self.select_output_file7)
        self.dlg.statSavefileB.clicked.connect(self.select_output_file8)
        self.dlg.stgeofileB.clicked.connect(self.select_output_file9)
        self.dlg.stprofileB.clicked.connect(self.select_output_file10)
        # Extract
        self.dlg.expointfileB.clicked.connect(self.select_open_file3)
        self.dlg.excsvfileB.clicked.connect(self.select_output_file11)
        self.dlg.expPLcrossB.clicked.connect(self.select_output_file19)
        # Group
        self.dlg.gmapPlotB.clicked.connect(self.select_output_file12)
        self.dlg.gtifExB.clicked.connect(self.select_output_file13)
        self.dlg.gtssfileB.clicked.connect(self.select_output_file14)
        self.dlg.gtsefileB.clicked.connect(self.select_output_file15)
        # Clip/Join
        self.dlg.cjdirB.clicked.connect(self.select_directory)
        self.dlg.cjnctxtB.clicked.connect(self.select_output_file16)
        self.dlg.cjnctxtBR.clicked.connect(self.select_open_file4)
        self.dlg.jncfileB.clicked.connect(self.select_output_file17)
        self.dlg.sncfileB.clicked.connect(self.select_output_file18) 
        # GIS
        self.dlg.gisAdtcsB.clicked.connect(self.select_open_file5)
        self.dlg.gisAkm2B.clicked.connect(self.select_open_file6)
        self.dlg.gisAoutB.clicked.connect(self.select_output_file20) 
        
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = False
        
            
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
      
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('XrasterPlug', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/xraster_gis/iconXrast2.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Multi Raster'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Xraster '),
                action)
            self.iface.removeToolBarIcon(action)

    def select_open_file1(self):
        """ Open .nc file"""
        # clear 
        
        global ppath
        filenamet=QFileDialog.getOpenFileName(self.dlg,"Input .nc file",ppath,'*.nc')
        filename=str(filenamet[0])
        if filename!='':
            ppath=os.path.dirname(filename)   
        self.dlg.ncdata.setText(filename)
        
        self.dlg.mask.setText('')
        self.dlg.sxres.setText('')
        self.dlg.syres.setText('')
        self.dlg.maskB.setEnabled(False)
        self.runTOOL("data")
        self.runTOOL("data_ord")
        
    
    def select_open_file2(self):
        """ Open mask .tif file"""
        global ppath
        filenamet=QFileDialog.getOpenFileName(self.dlg,"Input .tif file",ppath,'*.tif')
        filename=str(filenamet[0])
        if filename!='':
            ppath=os.path.dirname(filename)   
        self.dlg.mask.setText(filename)
        self.runTOOL("mask")
        
    def select_open_file3(self):
        """ Open points .shp file"""
        global ppath
        filenamet=QFileDialog.getOpenFileName(self.dlg,"Input .shp file",ppath,'*.shp')
        filename=str(filenamet[0])
        if filename!='':
            ppath=os.path.dirname(filename)   
        self.dlg.expointfile.setText(filename)
        self.dlg.cross_sel.setEnabled(True) 
        self.dlg.cross_np.setEnabled(True) 
        self.dlg.label_pi.setEnabled(True) 

    def select_open_file5(self):
        """ Open csv file"""
        global ppath
        filenamet=QFileDialog.getOpenFileName(self.dlg,"Input .csv file",ppath,'*.csv')
        filename=str(filenamet[0])
        if filename!='':
            ppath=os.path.dirname(filename)   
        self.dlg.gisAdtcs.setText(filename)

    def select_open_file6(self):
        """ Open csv file"""
        global ppath
        filenamet=QFileDialog.getOpenFileName(self.dlg,"Input .csv file",ppath,'*.csv')
        filename=str(filenamet[0])
        if filename!='':
            ppath=os.path.dirname(filename)   
        self.dlg.gisAkm2.setText(filename)         
       
        
    def select_output_file1(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export plot file",ppath,'*.jpg')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.expPLfile.setText(filename2) 
        self.dlg.figEPlot.setEnabled(True)   

    def select_output_file2(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export map to geotif",ppath,'*.tif')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.expMap.setText(filename2) 
        self.dlg.figCSVE.setEnabled(True)   
        
    def select_output_file3(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export time series to .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.expTSfile.setText(filename2) 
        self.dlg.expTSfileB.setEnabled(True)  

    def select_output_file4(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export vertical profile to .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.exportVPfile.setText(filename2) 
        self.dlg.exportVPfileB.setEnabled(True)   

    def select_output_file5(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export cross-section to .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.exportCROSfile.setText(filename2) 
        self.dlg.exportCROSfileB.setEnabled(True)  

    def select_output_file6(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Summary statistics to .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.SBssfile.setText(filename2) 
        self.dlg.SBssfileB.setEnabled(True)  

    def select_output_file7(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Zonal statistics to .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.SBzsfile.setText(filename2) 
        self.dlg.SBzsfileB.setEnabled(True)  
 
    def select_output_file8(self):
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export plot file",ppath,'*.jpg')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.statSavefile.setText(filename2) 
        
    def select_output_file9(self):
        """ Open mask .tif file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export map to geotif",ppath,'*.tif')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.stgeofile.setText(filename2) 
    
    def select_output_file10(self):
        """ Open mask .tif file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export vertical profile to .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.stprofile.setText(filename2) 

    def select_output_file11(self):
        """ Output point extraction .csv file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export data file .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.excsvfile.setText(filename2) 
        
    def select_output_file12(self):
        """ Save plot as .jpg"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export plot file",ppath,'*.jpg')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.gmapPlotss.setText(filename2) 

    def select_output_file13(self):
        """ Save.tif file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export map to geotif",ppath,'*.tif')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.gtifEx.setText(filename2)     

    def select_output_file14(self):
        """ Save plot as .jpg"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export plot file",ppath,'*.jpg')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.gtssfile.setText(filename2) 

    def select_output_file15(self):
        """ Output point extraction .csv file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export data file .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.gtsefile.setText(filename2)   

    def select_output_file19(self):
        """ Save plot as .jpg"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export plot file",ppath,'*.jpg')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.expPLcross.setText(filename2) 
        self.dlg.cross_plotS.setEnabled(True)      

    def select_output_file20(self):
        """ Output point extraction .csv file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Export data file .csv",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.gisAout.setText(filename2)           

    def  select_directory(self): 
        global ppath
        filenamet2=QFileDialog.getExistingDirectory(None, 'Select directory')
        filename2=str(filenamet2)
        if filename2!='':
            ppath=os.path.dirname(filename2)
            self.dlg.cjnctxtB.setEnabled(True)
        else:
            self.dlg.CreateB.setEnabled(False)
            self.dlg.cjnctxtB.setEnabled(False)
        self.dlg.cjdir.setText(filename2) 

    def select_output_file16(self):
        """ Text file (csv) with .nc files"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Text file with .nc",ppath,'*.csv')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.cjnctxt.setText(filename2) 
        self.dlg.CreateB.setEnabled(True) 
        self.dlg.cjaddB.setEnabled(False)
        self.dlg.cjaddallB.setEnabled(False)
        self.dlg.cjclearB.setEnabled(False)
        self.dlg.cjlist.setText('') 
        self.dlg.varBox2.clear()        
        
    def select_open_file4(self):
        """ Open file with .nc"""
        global ppath
        global var_list2,sssL
        
        filenamet=QFileDialog.getOpenFileName(self.dlg,"Input .csv file",ppath,'*.csv')
        filename=str(filenamet[0])
        if filename!='':
            ppath=os.path.dirname(filename)   
        self.dlg.cjnctxt.setText(filename)  
        self.dlg.CreateB.setEnabled(False)
        in_p=open(filename,"r")
        ii=0
        for line in in_p.readlines():
            if ii==0:
                sssd=line.split('\n')
            ii+=1    
        in_p.close()
        dss3=xr.open_dataset(sssd[0])
        var_list2=[];
        for var in dss3.data_vars:
            var_data=dss3[var]
            var_list2.append(var)
        dss3=None 
        self.dlg.varBox2.clear()
        for i in range(len(var_list2)):
            self.dlg.varBox2.addItem(var_list2[i]) 
        self.dlg.cjaddB.setEnabled(True)
        self.dlg.cjaddallB.setEnabled(True)
        self.dlg.cjclearB.setEnabled(True) 
        procc=0
        self.dlg.progressBar2.setValue(procc)          

    def select_output_file17(self):
        """ Output .nc file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Create .nc file",ppath,'*.nc')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.jncfile.setText(filename2) 
        self.dlg.JoinB.setEnabled(True)

    def select_output_file18(self):
        """ Output .nc file"""
        global ppath
        filenamet2=QFileDialog.getSaveFileName(self.dlg,"Create .nc file",ppath,'*.nc')
        filename2=str(filenamet2[0])
        if filename2!='':
            ppath=os.path.dirname(filename2)
        self.dlg.sncfile.setText(filename2)
        self.dlg.SaveB.setEnabled(True)        

        
#-------------------------------------------        
#-----------------------------------------------------------------------------        
    def runTOOL(self,mflow):
        # GLOBAL VARIABLES
        global stype,slat,slon,stime,szet,ngeo
        global mmask, mmtime
        global COORN
        global ds2
        global ds22
        global ds22C
        global ds222
        global ds222ST
        global dsg,dsgg,ltg,gstat,gtime
        global l_c
        global l_d
        global l_ci
        global dlist
        global xmin_val, xmax_val, ymin_val, ymax_val, zmin_val, zmax_val, tmin_val, tmax_val
        global figsize
        global fasp
        global ffont
        global fdpi
        global sX,sY,sZ,sT
        global fn  # mask name
        global varr
        global mfilter
        global ffm
        global var_list2,sssL
        global order_sss, inputerr
        global ekstrpointff,pointffc,iscross, ltime  
        
        # FUNCTIONS
        def l_ci_XYT(l_c,l_d):
            def e_in_list(list1, list2, index):
                # Check if the index is within the bounds of list1
                if index < 0 or index >= len(list1):
                    raise IndexError("Index out of bounds for the first list.")
                
                # Get the element at the specified index
                element = list1[index]
                
                # Check if the element is in the second list
                return element in list2
            l_ci=[]
            done=0
            for i in range(COORN):
                done=0
                for j in range(len(l_c)):        
                    if ('x' in l_c[j] or 'X' in l_c[j] or 'lon' in l_c[j] or 'Lon' in l_c[j]) and done==0 and i==0:
                            if e_in_list(l_c,l_d,j):
                                l_ci.append(j)
                                done=1
                            #else:
                                #l_ci.append(-1)
                                #done=1
                for j in range(len(l_c)):        
                    if ('y' in l_c[j] or 'Y' in l_c[j] or 'lat' in l_c[j] or 'Lat' in l_c[j] ) and done==0 and i==1:
                                if e_in_list(l_c,l_d,j):
                                    l_ci.append(j)
                                    done=1
                                #else:
                                    #l_ci.append(-1)
                                    #done=1           
                for j in range(len(l_c)):        
                    if ('time' in l_c[j] or 'Time' in l_c[j]) and done==0 and i==2:
                                if e_in_list(l_c,l_d,j):
                                    l_ci.append(j)
                                    done=1
                                #else:
                                    #l_ci.append(-1)
                                    #done=1   
                                    
                for j in range(len(l_c)):        
                    if ('z' in l_c[j] or 'Z' in l_c[j] or 'dep' in l_c[j] or 'Dep' in l_c[j] ) and done==0 and i==3:
                                if e_in_list(l_c,l_d,j):
                                    l_ci.append(j)
                                    done=1
                                #else:
                                    #l_ci.append(-1)
                                    #done=1
                if done==0:
                    l_ci.append(-1)                      
            return l_ci

        def timestamp_to_string_no_leading_zeros(ts: Timestamp) -> str:
            year = ts.year
            month = ts.month
            day = ts.day
            hour = ts.hour
            minute = ts.minute    
            return f"{year}-{month}-{day} {hour}:{minute}"
            
        def string_to_list(input_str):
            # Check if the string contains only digits and commas
            if not all(c.isdigit() or c == ',' for c in input_str):
                return 0
            
            try:
                # Split the string by commas and convert to integers
                num_list = list(map(int, input_str.split(',')))
                return num_list
            except ValueError:
                return 0  
                
        def stypeDEF(slon,slat,stime):
            nslon=len(slon.split(','))
            nslat=len(slat.split(','))
            nstime=len(stime.split(','))
            stype=0
            if nslon==2 or nslat==2:
                if nstime==2:
                    stype=1
                if nstime==1:
                    stype=2
            elif nslon==1 and nslat==1: 
                if nstime==2:
                    stype=3
                if nstime==1:
                    stype=4            
            return stype 
            
        def stypeDEF4(slon,slat,sz,stime):
            nslon=len(slon.split(','))
            nslat=len(slat.split(','))
            nsz=len(sz.split(','))
            nstime=len(stime.split(','))
            stype=0
            if nslon==2 or nslat==2:
                if nstime==2 and nsz==2:
                    stype=1
                if nstime==2 and nsz==1:
                    stype=11
                if nstime==1 and nsz==1:
                    stype=2
                if nstime==1 and nsz==2:
                    stype=22
            elif nslon==1 and nslat==1: 
                if nstime==2 and nsz==1:
                    stype=3
                if nstime==2 and nsz==2:
                    stype=33    
                if nstime==1 and nsz==1:
                    stype=4           
                if nstime==1 and nsz==2:
                    stype=44            
            return stype
        
        
        def AcBu(mflow):
            if mflow=='data':
                # clean global data
                ds2=None
                ds22=None
                ds22C=None
                ds222=None
                ds222ST=None
                dsg=None;dsgg=None
                self.dlg.selectB.setEnabled(False)
                self.dlg.resetB.setEnabled(False)
                
                #self.dlg.orderB.setEnabled(True)
                self.dlg.info.setEnabled(False)
                self.dlg.areakm2.setEnabled(False)
                self.dlg.resampl.setEnabled(False)
                #self.dlg.maskBrun.setEnabled(False)
                self.dlg.plotMB.setEnabled(False) 
                self.dlg.varBox.clear()
                self.dlg.labelSEL.setText('')
                # clear text windows
                sscl=''
                self.dlg.sXX.setText(sscl);self.dlg.sYY.setText(sscl);self.dlg.sZZ.setText(sscl)
                self.dlg.sTIME.setText(sscl);self.dlg.calc.setText(sscl);self.dlg.filter.setText(sscl)
                self.dlg.sMonths.setText(sscl);self.dlg.expPLfile.setText(sscl);self.dlg.SBssfile.setText(sscl)
                self.dlg.statSavefile.setText(sscl);self.dlg.excsvfile.setText(sscl);self.dlg.filter.setText(sscl)
                self.dlg.figType.setText('')  
                # clear Clip/Join
                self.dlg.CreateB.setEnabled(False)
                self.dlg.cjnctxtB.setEnabled(False)
                self.dlg.cjdir.setText('')   
                self.dlg.cjnctxt.setText('') 
            if mflow=='data_ord':
                self.dlg.info.setEnabled(True)
                self.dlg.areakm2.setEnabled(True)
                self.dlg.resampl.setEnabled(True)
                #self.dlg.maskBrun.setEnabled(True)
                self.dlg.maskB.setEnabled(True)
                self.dlg.resetB.setEnabled(True)
                self.dlg.selectB.setEnabled(True)

        def convert_to_int(text, lowest_allowed, highest_allowed, default_value):
            try:
                value = float(text)
                if lowest_allowed <= value <= highest_allowed:
                    return value
                else:
                    return default_value
            except ValueError:
                return default_value
                
        def extract_floats(str1, str2):
            # Split both strings by commas
            values1 = str1.split(',')
            values2 = str2.split(',')
            
            # Extract the second value from the first string and the first value from the second string
            if self.dlg.mask_flip.isChecked():
                return float(values1[0]), float(values2[0]) 
            else:
                return float(values1[1]), float(values2[0]) 
        
        def is_valid_integer_string(s):
            # Regular expression to match a single integer or multiple integers separated by commas
            pattern = r"^\d+(,\d+)*$"
            
            # Use the regex to check if the input string matches the pattern
            return bool(re.match(pattern, s))
            
        def is_valid_point_shapefile(filepath):
            """
            Check if a file is a valid point shapefile and if the first column
            contains unique integer IDs.

            :param filepath: Path to the shapefile.
            :return: True if valid, False otherwise, along with an error message.
            """
            try:
                # Open the shapefile
                datasource = ogr.Open(filepath)
                if datasource is None:
                    return False#, "Could not open the shapefile."

                # Get the first layer
                layer = datasource.GetLayer()

                # Check if the geometry is of type Point
                layer_defn = layer.GetLayerDefn()
                geom_type = layer_defn.GetGeomType()
                if geom_type != ogr.wkbPoint:
                    return False#, "The file is not a Point shapefile."

                # Get the first field (column) definition
                first_field = layer_defn.GetFieldDefn(0)
                first_field_name = first_field.GetName()
                first_field_type = first_field.GetType()

                # Check if the first field is of integer type
                if first_field_type not in (ogr.OFTInteger, ogr.OFTInteger64):
                    return False#, f"The first field '{first_field_name}' is not an integer type."

                # Extract all values of the first field
                field_values = []
                for feature in layer:
                    field_values.append(feature.GetField(first_field_name))

                # Check if the field values are unique
                df = pd.DataFrame(field_values, columns=[first_field_name])
                if df[first_field_name].is_unique:
                    return True#, "The file is a valid point shapefile with unique integer IDs."
                else:
                    return False#, f"The first field '{first_field_name}' does not have unique values."

            except Exception as e:
                return False#, f"Error reading the shapefile: {str(e)}"            
            
        def list_nc_files_to_txt(directory, output_file):
            """
            Recursively list all .nc files in the given directory (including subdirectories)
            and write their full paths to a text file.

            :param directory: The base directory to start searching for .nc files.
            :param output_file: The path of the text file where the results will be written.
            """
            with open(output_file, 'w') as file:
                # Traverse the directory tree
                for root, dirs, files in os.walk(directory):
                    # Find all files with the .nc extension
                    for filename in files:
                        if filename.endswith('.nc'):
                            # Write the full path of the .nc file to the text file
                            full_path = os.path.join(root, filename)
                            file.write(full_path + '\n')

        def extract_date_from_filename(filename):
            """
            Extracts the date from the filename. Supports YYYYMMDD and YYYY-MM formats.
            """
            # Regex patterns for YYYYMMDD and YYYY-MM formats
            patterns = [
                r'(\d{4})(\d{2})(\d{2})',  # Matches YYYYMMDD
                r'(\d{4})-(\d{2})'        # Matches YYYY-MM
            ]
            
            for pattern in patterns:
                match = re.search(pattern, filename)
                if match:
                    try:
                        if len(match.groups()) == 3:  # YYYYMMDD format
                            return datetime.strptime("".join(match.groups()), '%Y%m%d')
                        elif len(match.groups()) == 2:  # YYYY-MM format
                            return datetime.strptime("-".join(match.groups()), '%Y-%m')
                    except ValueError:
                        pass
            return None

        def sort_files_by_date(input_csv, output_csv):
            """
            Reads the input CSV containing full file paths, extracts dates from the filenames,
            sorts the files by the extracted dates, and writes the sorted file paths to an output CSV.
            """
            files_with_dates = []

            # Read the input CSV
            with open(input_csv, 'r') as file:
                reader = csv.reader(file)
                for row in reader:
                    if row:  # Ensure the row is not empty
                        filepath = row[0]
                        filename = filepath.split('/')[-1]  # Get the file name from the full path
                        file_date = extract_date_from_filename(filename)
                        
                        if file_date:
                            files_with_dates.append((filepath, file_date))
            
            # Sort files based on the extracted date
            sorted_files = sorted(files_with_dates, key=lambda x: x[1])
            
            # Write the sorted files to the output CSV
            with open(output_csv, 'w', newline='') as file:
                writer = csv.writer(file)
                for filepath, _ in sorted_files:
                    writer.writerow([filepath])    
            
        def convert_to_float(value):
            """
            Convert input to float if it is in the range [-180, 180].
            Return the float value if valid, otherwise return 999.
            
            Args:
                value (str): The input string, empty string, or convertible value.
            
            Returns:
                float: The converted float value or 999.
            """
            try:
                # Handle empty input explicitly
                if value == "" or value is None:
                    return 999
                
                # Attempt to convert to float
                float_value = float(value)
                
                # Check if it is within the range -180 to 180
                if -180 <= float_value <= 180:
                    return float_value
                else:
                    return 999
            except (ValueError, TypeError):
                # Return 999 if conversion fails
                return 999
        def convert_to_data_csv_path(file_path):
            """
            Takes a file path with any extension and returns a path to a file
            with the same base name but with '_data.csv' as the new extension.

            Args:
                file_path (str): The input file path.

            Returns:
                str: The modified file path with '_data.csv' as the new extension.
            """
            base_name = os.path.splitext(file_path)[0]  # Remove the original extension
            new_file_path = f"{base_name}_data.csv"    # Append '_data.csv' to the base name
            return new_file_path
            
        def add_points_on_segment(input_shapefile, nd, output_shapefile):
            # Open the input shapefile
            driver = ogr.GetDriverByName("ESRI Shapefile")
            dataSource = driver.Open(input_shapefile, 0)
            if dataSource is None:
                raise ValueError("Could not open input shapefile")
            
            layer = dataSource.GetLayer()
            
            # Collect the two points
            points = []
            ids = []
            for feature in layer:
                geom = feature.GetGeometryRef()
                if geom.GetGeometryType() == ogr.wkbPoint:
                    points.append((geom.GetX(), geom.GetY()))
                    ids.append(feature.GetField("Id"))
            
            if len(points) != 2:
                raise ValueError("Input shapefile must contain exactly two points")
            
            # Sort points based on spatial order from first to second
            if ids[0] > ids[1]:
                points.reverse()
                ids.reverse()
            
            (x1, y1), (x2, y2) = points
            
            # Compute equally spaced points
            dx = (x2 - x1) / (nd + 1)
            dy = (y2 - y1) / (nd + 1)
            
            # Create output shapefile
            if os.path.exists(output_shapefile):
                driver.DeleteDataSource(output_shapefile)
            
            outDataSource = driver.CreateDataSource(output_shapefile)
            outLayer = outDataSource.CreateLayer("points", layer.GetSpatialRef(), ogr.wkbPoint)
            
            # Create ID field
            idField = ogr.FieldDefn("Id", ogr.OFTInteger)
            outLayer.CreateField(idField)
            
            # Add first original point
            new_feature = ogr.Feature(outLayer.GetLayerDefn())
            new_feature.SetField("Id", ids[0])
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, x1, y1)
            new_feature.SetGeometry(point)
            outLayer.CreateFeature(new_feature)
            new_feature = None
            
            # Add new interpolated points
            for i in range(1, nd + 1):
                new_x = x1 + i * dx
                new_y = y1 + i * dy
                
                new_feature = ogr.Feature(outLayer.GetLayerDefn())
                new_feature.SetField("Id", ids[0] + i)
                
                point = ogr.Geometry(ogr.wkbPoint)
                point.SetPoint(0, new_x, new_y)
                new_feature.SetGeometry(point)
                
                outLayer.CreateFeature(new_feature)
                new_feature = None
            
            # Add second original point with adjusted ID
            new_feature = ogr.Feature(outLayer.GetLayerDefn())
            new_feature.SetField("Id", ids[0] + nd + 1)
            point = ogr.Geometry(ogr.wkbPoint)
            point.SetPoint(0, x2, y2)
            new_feature.SetGeometry(point)
            outLayer.CreateFeature(new_feature)
            new_feature = None
            
            # Cleanup
            outDataSource = None
            dataSource = None        

        def calculate_xarray_dimensions(file_path):
            # Read the CSV file
            df = pd.read_csv(file_path, parse_dates=['time'])
            
            # Ensure required columns exist
            required_columns = {'IDpoint', 'X', 'Y', 'time', 'depth'}
            if not required_columns.issubset(df.columns):
                raise ValueError(f"Missing required columns: {required_columns - set(df.columns)}")
            
            # Get unique values for each dimension
            time_values = pd.to_datetime(df['time']).sort_values().unique()
            depth_values = sorted(df['depth'].unique())
            idpoint_values = sorted(df['IDpoint'].unique())
            
            return time_values, depth_values, idpoint_values, df

        def get_coordinate_system(shapefile):
            driver = ogr.GetDriverByName("ESRI Shapefile")
            dataSource = driver.Open(shapefile, 0)
            if dataSource is None:
                raise ValueError("Could not open input shapefile")
            
            layer = dataSource.GetLayer()
            spatial_ref = layer.GetSpatialRef()
            
            if spatial_ref is None:
                raise ValueError("Shapefile has no coordinate reference system")
            
            return spatial_ref.IsGeographic(), spatial_ref

        def calculate_distance(x1, y1, x2, y2, is_geographic, spatial_ref):
            point1 = ogr.Geometry(ogr.wkbPoint)
            point1.AddPoint(x1, y1)
            
            point2 = ogr.Geometry(ogr.wkbPoint)
            point2.AddPoint(x2, y2)
            
            if is_geographic:
                # Determine UTM zone from longitude
                utm_zone = int((x1 + 180) / 6) + 1
                target_srs = osr.SpatialReference()
                target_srs.ImportFromEPSG(32600 + utm_zone)  # WGS84 UTM zone
                
                transform = osr.CoordinateTransformation(spatial_ref, target_srs)
                point1.Transform(transform)
                point2.Transform(transform)
            
            return point1.Distance(point2) / 1000  # Convert meters to kilometers

        def create_xarray_dataarray(file_path, shapefile):
            # Read the CSV file
            df = pd.read_csv(file_path, parse_dates=['time'])
            
            # Extract variable name (assuming it's the last column)
            variable_name = df.columns[-1]
            
            # Get dimensions
            time_values, depth_values, idpoint_values, df = calculate_xarray_dimensions(file_path)
            
            # Determine coordinate system
            is_geographic, spatial_ref = get_coordinate_system(shapefile)
            
            # Compute distances from the first point
            first_point = df[df['IDpoint'] == idpoint_values[0]][['X', 'Y']].iloc[0]
            df['distance_km'] = df.apply(lambda row: calculate_distance(first_point.X, first_point.Y, row.X, row.Y, is_geographic, spatial_ref), axis=1)
            
            # Create an empty DataArray with NaNs
            data_array = xr.DataArray(
                data=float("nan"),  # Start with NaNs to be filled later
                dims=("time", "depth", "distance_km"),
                coords={
                    "time": time_values,
                    "depth": depth_values,
                    "distance_km": sorted(df['distance_km'].unique())
                }
            )
            
            # Fill the DataArray with actual values
            for _, row in df.iterrows():
                data_array.loc[row['time'], row['depth'], row['distance_km']] = row[variable_name]
            
            return data_array

        def get_time_coordinates_as_strings(data_array):
            return [pd.Timestamp(time).strftime("%Y-%m-%d %H") for time in data_array.coords["time"].values]

        def has_exactly_two_unique_points(shapefile_path):
            # Open the shapefile
            driver = ogr.GetDriverByName("ESRI Shapefile")
            data_source = driver.Open(shapefile_path, 0)  # 0 means read-only
            
            if data_source is None:
                print("Could not open file.")
                return False
            
            layer = data_source.GetLayer()
            
            # Store unique points in a set
            unique_points = set()
            
            for feature in layer:
                geom = feature.GetGeometryRef()
                if geom and geom.GetGeometryType() == ogr.wkbPoint:
                    x, y = geom.GetX(), geom.GetY()
                    unique_points.add((x, y))
                    
                # If we find more than two unique points, return early
                if len(unique_points) > 2:
                    return False
            
            return len(unique_points) == 2

        
        def read_timecross_to_numpy(file_path):
            data = []
            with open(file_path, 'r') as f:
                next(f)  # Skip header
                for line in f:
                    year_str, depth_str, var_str = line.strip().split(',')
                    year = int(year_str)
                    depth = float(depth_str)
                    var = float(var_str)
                    data.append([year, depth, var])
            
            data_array = np.array(data, dtype=float)
            #print(f"Data shape: {data_array.shape}")
            return data_array    
            
        # DATA TAB --------------------------------------------------------------------------
        
        # Test packages
        package_name = 'xarray'
        spec = importlib.util.find_spec(package_name)
        if spec is None:
            sss=f'Package {package_name} is not installed'
            self.dlg.infodata.appendPlainText(sss)
            mflow='zero'
        package_name = 'netCDF4'
        spec = importlib.util.find_spec(package_name)
        if spec is None:
            sss=f'Package {package_name} is not installed'
            self.dlg.infodata.appendPlainText(sss)
            mflow='zero'
        package_name = 'h5netcdf'
        spec = importlib.util.find_spec(package_name)
        if spec is None:
            sss=f'Package {package_name} is not installed'
            self.dlg.infodata.appendPlainText(sss)
            mflow='zero'
        
        if mflow=='zero':
           sss=f'To install package use OSGeo4W Shell (as Administrator)'
           self.dlg.infodata.appendPlainText(sss)
           sss=f'Input in C:\OSgeo4W'
           self.dlg.infodata.appendPlainText(sss)
           sss=f'python3 -m pip install <package_name>'
           self.dlg.infodata.appendPlainText(sss)
           sss=f'see movie:  xxxxxx'
           self.dlg.infodata.appendPlainText(sss)
           
        if mflow=='data':
            inputerr=0
            AcBu(mflow)
            self.dlg.infodata.clear()
            ncfile=self.dlg.ncdata.text()
            try:
                ds2=xr.open_dataset(ncfile)
                # X,Y,time z order
                stype=0
                mmask=0

                l_c=[]
                for coord in ds2.coords:
                    l_c.append(coord)
                l_d=[]    # only if exists in l_c
                for xyz in ds2.dims:
                    if xyz in l_c:
                        l_d.append(xyz)
                                
                COORN=len(l_d)    # liczba coordinates  3 lub 4
                l_ci=[]
                l_ci=l_ci_XYT(l_c,l_d)

                sCOORN=COORN
                if sCOORN<3:

                    l_d=[]
                    for xyz in ds2.dims:
                         l_d.append(xyz)
                    #print('Dimensions:')
                    dlist=list(ds2.dims.items())
                    for i in range(len(dlist)):
                        #print(dlist[i][0],dlist[i][1])
                        syx=dlist[i][0]
                        if 'x' in syx or 'X' in syx or 'lon' in syx or 'Lon' in syx:
                                xxx=np.arange(0,dlist[i][1]).tolist()
                                sds2=f"ds2.assign_coords({syx}=(['{syx}'],{xxx}))"
                                code = compile(sds2, "<string>", "eval")
                                ds2=eval(code,{'ds2':ds2})
                        if 'y' in syx or 'Y' in syx or 'lat' in syx or 'Lat' in syx:
                                yyy=np.arange(0,dlist[i][1]).tolist()
                                sds2=f"ds2.assign_coords({syx}=(['{syx}'],{yyy}))"        
                                code = compile(sds2, "<string>", "eval")
                                ds2=eval(code,{'ds2':ds2})

                    COORN=len(l_d)    # liczba coordinates  3 lub 4
                    l_c=[]
                    for coord in ds2.coords:
                        l_c.append(coord)

                    l_ci=[]
                    l_ci=l_ci_XYT(l_c,l_d)
             
                
                
                # if COORN==3:
                    # sss=f'Dimensions: {l_c[:3]}\n'
                # elif COORN==4:
                    # sss=f'Dimensions: {l_c[:4]}\n'
                # self.dlg.infodata.appendPlainText(sss)
                if COORN==3:
                    sss=f'{l_ci[0]},{l_ci[1]},{l_ci[2]}'
                elif COORN==4:
                    sss=f'{l_ci[0]},{l_ci[1]},{l_ci[2]},{l_ci[3]}'
                #self.dlg.order.setText(sss)
                order_sss=sss
            except:
                sss=f'!!!! Not valid NetCDF [.nc] file or no time dimension. !!!!'
                inputerr=1
                self.dlg.infodata.appendPlainText(sss)
                self.dlg.maskB.setEnabled(False)

            # group
            self.dlg.GRrun.setEnabled(False) 
            self.dlg.gmapPlot.setEnabled(False)
            self.dlg.gmapsPlot.setEnabled(False)
            self.dlg.gmapExp.setEnabled(False)
            self.dlg.gtsPlot.setEnabled(False)
            self.dlg.gtssPlot.setEnabled(False)
            self.dlg.gtsExp.setEnabled(False)
            # figures
            self.dlg.Npolarst.setEnabled(False)
            self.dlg.gsubset.setEnabled(False)
            self.dlg.gsubset.setChecked(False)
            self.dlg.Spolarst.setEnabled(False)
            self.dlg.polarstcm.setEnabled(False)
            self.dlg.label_pst.setEnabled(False)
            self.dlg.coastt.setEnabled(False)    
                
        
        if mflow=='data_ord' and inputerr==0:
            AcBu(mflow)
            sinfo=''
            #self.dlg.labelSEL.setText('Press OK and wait ...')
            l_c=[]
            #sl_ci=self.dlg.order.text()
            sl_ci=order_sss
            if string_to_list(sl_ci)!=0:
                l_ci=string_to_list(sl_ci)
                
            for coord in ds2.coords:
                l_c.append(coord)
            ddtype=ds2.coords.dtypes
            l_dd=[]
            #out_plik=open(r'D:\XRAST\QXR\LOG\LLOG.txt','w')
            for i in range(len(l_c)):
                dd=ddtype.get(l_c[i])
                l_dd.append(dd.name) 
                #out_plik.write(f'{i},{l_dd[i]}\n')
                
            
            # dimensions
            sinfo=sinfo+f'Dimensions:\n'
            dlist=list(ds2.sizes.items())
            for i in range(len(dlist)):
                sinfo=sinfo+f'  {dlist[i][0]},{dlist[i][1]}\n'

            # coordinates
            mmask=0
            mmtime=0
            xycords=[]
            sinfo=sinfo+f'Coordinates:\n'
            
            #out_plik.close()
            xmin_val=0;ymin_val=0;tmin_val=0;zmin_val=0
            xmax_val=0;ymax_val=0;tmax_val=0;zmax_val=0
            ic=0
            for coord in ds2.coords:
                coord_data = ds2[coord]
                if l_dd[ic] != 'object' and l_dd[ic] != 'str128' and l_dd[ic] != 'str64': 
                    min_val = round(float(coord_data.min()),4)    
                    max_val = round(float(coord_data.max()),4)
                if ic==l_ci[2]:
                    min_val=pd.to_datetime(min_val)
                    max_val=pd.to_datetime(max_val)
                    tmin_val=min_val;tmax_val=max_val
                elif ic==l_ci[0]:
                    xmin_val=min_val;xmax_val=max_val
                elif ic==l_ci[1]:
                    ymin_val=min_val;ymax_val=max_val
                else:
                    sinfo=sinfo+f'  {l_c[ic]},{min_val},{max_val}\n'
                if coord=='mask':
                    mmask=1
                if coord=='time':
                    mmtime=1                
                if COORN==4:
                    if ic==l_ci[3]:
                        zmin_val=min_val;zmax_val=max_val 
                ic+=1        
            sinfo=sinfo+f'  {l_c[l_ci[0]]},{xmin_val},{xmax_val}\n'
            sinfo=sinfo+f'  {l_c[l_ci[1]]},{ymin_val},{ymax_val}\n'
            sinfo=sinfo+f'  {l_c[l_ci[2]]},{tmin_val},{tmax_val}\n'
            

            if COORN==4:
                        #sinfo=sinfo+f'  {l_c[l_ci[3]]},{zmin_val},{zmax_val}\n'
                        pass
            # variables
            sinfo=sinfo+f'Variables:\n'
            var_list=[];
            for var in ds2.data_vars:
                var_data=ds2[var]
                var_list.append(var)
                unit = var_data.attrs.get('units', 'unknown')
                name = var_data.attrs.get('long_name', 'unknown')
                sinfo=sinfo+f'   {var} [{unit}]  {name} \n'
            self.dlg.infodata.appendPlainText(sinfo)
            # varBox fill
            self.dlg.varBox.clear()
            if mmtime==1:
                for i in range(len(var_list)):
                    self.dlg.varBox.addItem(var_list[i])
            # statBox fill (2)
            self.dlg.statBox.clear()
            self.dlg.stat2Box.clear()
            stat_list=['mean','median','std','min','max','sum','quantile(0.1)','quantile(0.9)']
            stat_list2=['mean','median','std','min','max','sum']
            for i in range(len(stat_list)):
                self.dlg.statBox.addItem(stat_list[i])
            for i in range(len(stat_list2)):
                self.dlg.stat2Box.addItem(stat_list2[i])           
            # periodBox fill
            self.dlg.periodBox.clear()
            per_list=['year','month','day','season']
            for i in range(len(per_list)):
                self.dlg.periodBox.addItem(per_list[i]) 
            
            # info in subset
            sss = (f"CALCULATE - calculates a variable using a simple\n"
               f"expression in the form [variable rest_of_expression].\n"
               f"Only the rest_of_expression is entered. For example,\n"
               f"converting Kelvin to Celsius will take the form\n"
               f"  -272.15, the expression will look like [var-272.15].\n"
               f"An empty field means *1, with the expression [var*1].\n"
               f"Each variable may be input to expression as ds2.var_name .\n\n"
               f"SUBSET SELECTION - empty fields mean the full range of data.\n"
               f"Slices of dimensions can be entered, e.g.\n"
               f"18.2345,19.0\n"
               f"54.23,55.5\n"
               f"5.0,15.0\n"
               f"Time is entered in the following format (without leading zeros)\n"
               f"'2004-7-1','2004-7-31'\n"
               f"Coordinates of a point and moment in time can also be entered\n"
               f"18.2345\n"
               f"54.23\n"
               f"5.0\n"
               f"'2004-7-1'\n\n"
               f"FILTER - Most often used with a mask\n"
               f"to select data from a specific area,\n"
               f"it uses the word where and a condition [where(var.mask>0)],\n"
               f"it can use logical operators or | , and &. e.g.\n"
               f" where((var.mask==1) | (var.mask==2))\n" 
               f"it can also be used for a variable e.g.\n"
               f" where(var<10.0) \n\n"
               f"MONTHS SELECTION - allows for selecting data from specific \n"
               f"months using a list of their numbers, e.g.\n"
               f" 11,12,1,2,3,4 \n"
               f"-------------------------------------------------------------\n"
               f"                 SUBSET TYPES \n"
               f"Dimensions      Subset Type     Description\n"
               f" 3 (x,y,time)          1    -    Slices of space and time \n"
               f" 3                       2    -    Slice of space at a single time \n"
               f" 3                       3    -    Point in space and time slice \n"
               f" 3                       4    -    Point in space at a single time \n"
               f" 4 (x,y,depth,time)    1    -    Slices of space,time and depth \n"
               f" 4                       11   -    Slices of space and time for a single depth \n"
               f" 4                       2    -    Slice of space at a single time  and depth \n" 
               f" 4                       22   -    Slices of space and depth at a single time \n"
               f" 4                       3    -    Point in space, single depth, and time slice \n"
               f" 4                       33   -    Point in space with slices of time and depth \n"
               f" 4                       4    -    Point in space at a single time and depth \n"
               f" 4                       44   -    Point in space with a slice of depth at a single time \n")
            self.dlg.subsetInfo.clear()
            self.dlg.subsetInfo.appendPlainText(sss)
            sss2 = (f"Dimensions, subset type,   order of columns with dimension change \n\n"
               f"3             1                point(1), time(2)\n"
               f"3             2                point(1)\n"
               f"4             1                point(1), time(2), depth(3)\n"
               f"4             2                point(1)\n"
               f"4             11               point(1), time(2)\n"
               f"4             22               point(1), depth(2)\n")
            self.dlg.extractInfo.clear()
            self.dlg.extractInfo.appendPlainText(sss2)
            if COORN==3:
                self.dlg.sZZ.setEnabled(False)
            else:
                self.dlg.sZZ.setEnabled(True)
            self.dlg.EXTrun.setEnabled(False)
            
            # clear text windows in program
            sscl=''
            self.dlg.sXX.setText(sscl);self.dlg.sYY.setText(sscl);self.dlg.sZZ.setText(sscl)
            self.dlg.sTIME.setText(sscl);self.dlg.calc.setText(sscl);self.dlg.filter.setText(sscl)
            self.dlg.sMonths.setText(sscl);self.dlg.expPLfile.setText(sscl);self.dlg.SBssfile.setText(sscl)
            self.dlg.statSavefile.setText(sscl);self.dlg.excsvfile.setText(sscl);self.dlg.filter.setText(sscl)
            self.dlg.figType.setText('')
            self.dlg.maskB.setEnabled(True)
            
        if mflow=='areakm':
            # Convert degrees to radians for calculations
            lat_rad = np.deg2rad(ds2[l_c[l_ci[1]]])
            lon_rad = np.deg2rad(ds2[l_c[l_ci[0]]])

            # Earth's radius in kilometers
            R = 6371.0

            # Calculate the differences between adjacent latitudes and longitudes
            dlat = np.abs(lat_rad.diff(l_c[l_ci[1]]).mean().values)  # In radians
            dlon = np.abs(lon_rad.diff(l_c[l_ci[0]]).mean().values)  # In radians

            # Approximate the area of each grid cell
            lat_mesh, lon_mesh = np.meshgrid(lat_rad, lon_rad, indexing='ij')
            km2 = (
                R**2 * dlon * 
                (np.sin(lat_mesh + dlat / 2) - np.sin(lat_mesh - dlat / 2))
            )

            # Add the area variable to the dataset
            ds2['km2'] = ((l_c[l_ci[1]], l_c[l_ci[0]]), km2)
            ds2['km2'].attrs['units']='km2'
            ds2['km2'].attrs['long_name']='Area of cell'
        
        if mflow=='resampln':
            xres=self.dlg.sxres.text()
            xresn=convert_to_int(xres,1,100,1)
            yres=self.dlg.syres.text()
            yresn=convert_to_int(yres,1,100,1)
            sxresn=str(int(xresn));syresn=str(int(yresn))

            sds2=f"ds2.coarsen({l_c[l_ci[0]]}={sxresn},{l_c[l_ci[1]]}={syresn},boundary='trim').mean()"
            code = compile(sds2, "<string>", "eval")
            ds2=eval(code,{'ds2':ds2}) 
            if mmask==1:
                ds2['mask']=ds2['mask'].round()

        
        if mflow=='info':
            sinfo=''
            l_c=[]
            for coord in ds2.coords:
                l_c.append(coord)
            # dimensions
            sinfo=sinfo+f'Dimensions:\n'
            dlist=list(ds2.sizes.items())
            for i in range(len(dlist)):
                sinfo=sinfo+f'  {dlist[i][0]},{dlist[i][1]}\n'
            
            # coordinates
            mmask=0
            xycords=[]
            sinfo=sinfo+f'Coordinates:\n'
            
            
            xmin_val=0;ymin_val=0;tmin_val=0;zmin_val=0
            xmax_val=0;ymax_val=0;tmax_val=0;zmax_val=0
            ic=0
            for coord in ds2.coords:
                coord_data = ds2[coord]
                min_val = round(float(coord_data.min()),4)
                max_val = round(float(coord_data.max()),4)
                if ic==l_ci[2]:
                    min_val=pd.to_datetime(min_val)
                    max_val=pd.to_datetime(max_val)
                    tmin_val=min_val;tmax_val=max_val
                elif ic==l_ci[0]:
                    xmin_val=min_val;xmax_val=max_val
                elif ic==l_ci[1]:
                    ymin_val=min_val;ymax_val=max_val
                else:
                    sinfo=sinfo+f'  {l_c[ic]},{min_val},{max_val}\n'
                if coord=='mask':
                    mmask=1
                if COORN==4:
                    if ic==l_ci[3]:
                        zmin_val=min_val;zmax_val=max_val 
                ic+=1        
            sinfo=sinfo+f'  {l_c[l_ci[0]]},{xmin_val},{xmax_val}\n'
            sinfo=sinfo+f'  {l_c[l_ci[1]]},{ymin_val},{ymax_val}\n'
            sinfo=sinfo+f'  {l_c[l_ci[2]]},{tmin_val},{tmax_val}\n'
            if COORN==4:
                        #sinfo=sinfo+f'  {l_c[l_ci[3]]},{zmin_val},{zmax_val}\n'
                        pass
            # variables
            sinfo=sinfo+f'Variables:\n'
            var_list=[];
            for var in ds2.data_vars:
                var_data=ds2[var]
                var_list.append(var)
                unit = var_data.attrs.get('units', 'unknown')
                name = var_data.attrs.get('long_name', 'unknown')

                sinfo=sinfo+f'   {var} [{unit}]  {name} \n'
            self.dlg.infodata.appendPlainText(sinfo)
            
        if mflow=='mask':    
            gdal.AllRegister()
            fn=self.dlg.mask.text()
            ds=gdal.Open(fn,gdal.GA_ReadOnly)
            if  ds is None:
                sss=f'!!!! Not valid mask [.tif] file. !!!!'
                self.dlg.infodata.appendPlainText(sss)
                self.dlg.plotMB.setEnabled(False)
                mask=0
            else:    
                band=None;rdata=None
                cols=ds.RasterXSize
                rows=ds.RasterYSize
                band=ds.GetRasterBand(1)
                rdata=band.ReadAsArray(0,0,cols,rows)
                xds=l_c[l_ci[0]]   
                yds=l_c[l_ci[1]]
                for i in range(len(dlist)):
                    if dlist[i][0]==xds:
                        xdsn=dlist[i][1]
                    if dlist[i][0]==yds:
                        ydsn=dlist[i][1]

                if (cols==xdsn) and (rows==ydsn):
                    tmask=np.flipud(rdata)    # obrcenie up-down
                    if self.dlg.mask_flip.isChecked():
                        tmask=rdata
                    ds=None
                    ds2.coords['mask']=((l_c[l_ci[1]],l_c[l_ci[0]]),tmask)
                    mmask=1 
                    self.dlg.plotMB.setEnabled(True)
                else:
                    sss=f'!!!! Mask has different dimension x={cols}, y={rows} !!!!'
                    self.dlg.infodata.appendPlainText(sss)
                    self.dlg.plotMB.setEnabled(False)
                    mask=0
                    
        if mflow=='mask_plot':
                smask='mask'
                # info
                sinfo=''
                l_c=[]
                for coord in ds2.coords:
                    l_c.append(coord)
                # dimensions
                sinfo=sinfo+f'Dimensions:\n'
                dlist=list(ds2.sizes.items())
                for i in range(len(dlist)):
                    sinfo=sinfo+f'  {dlist[i][0]},{dlist[i][1]}\n'
                
                # coordinates
                mmask=0
                xycords=[]
                sinfo=sinfo+f'Coordinates:\n'
                
                
                xmin_val=0;ymin_val=0;tmin_val=0;zmin_val=0
                xmax_val=0;ymax_val=0;tmax_val=0;zmax_val=0
                ic=0
                for coord in ds2.coords:
                    coord_data = ds2[coord]
                    min_val = round(float(coord_data.min()),4)
                    max_val = round(float(coord_data.max()),4)
                    if ic==l_ci[2]:
                        min_val=pd.to_datetime(min_val)
                        max_val=pd.to_datetime(max_val)
                        tmin_val=min_val;tmax_val=max_val
                    elif ic==l_ci[0]:
                        xmin_val=min_val;xmax_val=max_val
                    elif ic==l_ci[1]:
                        ymin_val=min_val;ymax_val=max_val
                    else:
                        sinfo=sinfo+f'  {l_c[ic]},{min_val},{max_val}\n'
                    if coord=='mask':
                        mmask=1
                    if COORN==4:
                        if ic==l_ci[3]:
                            zmin_val=min_val;zmax_val=max_val 
                    ic+=1        
                sinfo=sinfo+f'  {l_c[l_ci[0]]},{xmin_val},{xmax_val}\n'
                sinfo=sinfo+f'  {l_c[l_ci[1]]},{ymin_val},{ymax_val}\n'
                sinfo=sinfo+f'  {l_c[l_ci[2]]},{tmin_val},{tmax_val}\n'
                if COORN==4:
                            sinfo=sinfo+f'  {l_c[l_ci[3]]},{zmin_val},{zmax_val}\n'
                # variables
                sinfo=sinfo+f'Variables:\n'
                var_list=[];
                for var in ds2.data_vars:
                    var_data=ds2[var]
                    var_list.append(var)
                    unit = var_data.attrs.get('units', 'unknown')
                    sinfo=sinfo+f'   {var} [{unit}] \n'
                self.dlg.infodata.appendPlainText(sinfo)
                # info end
                if smask in l_c:
                    s_ds2='ds2.'+smask+'.plot(aspect=fasp,size=figsize);'
                    exec(s_ds2)
                    plt.show()
        
        if mflow=='Sreset':
            self.dlg.sZZ.setEnabled(True)
            slon=str(xmin_val)+","+str(xmax_val)
            
            sds2=f"float(ds2.{l_c[l_ci[1]]}[0])<float(ds2.{l_c[l_ci[1]]}[1])"
            code = compile(sds2, "<string>", "eval")
            ydir=eval(code,{'ds2':ds2})
            if ydir:
                slat=str(ymin_val)+","+str(ymax_val)
            else:
               slat=str(ymax_val)+","+str(ymin_val) 
               
            stmin_val = timestamp_to_string_no_leading_zeros(tmin_val)  
            stmax_val = timestamp_to_string_no_leading_zeros(tmax_val) 
            stime="'"+stmin_val+"'"+","+"'"+stmax_val+"'"
            if stmin_val==stmax_val:
               stime="'"+stmin_val+"'" 
            self.dlg.sXX.setText(slon)
            self.dlg.sYY.setText(slat)
            self.dlg.sTIME.setText(stime)
            if COORN==4:
                szet=str(zmin_val)+","+str(zmax_val)
                self.dlg.sZZ.setText(szet)                       
            ngeo=0
            self.dlg.labelSEL.setText('Press OK and wait ...')
        if mflow=='select':     
            iscross=0   # it is not cross-section
            ngeo=0     # georef maski
            # domylne wartoci penych zakresw
            slon=str(xmin_val)+","+str(xmax_val)
            slat=str(ymin_val)+","+str(ymax_val)
            if ymin_val < 0: 
               slat=str(ymax_val)+","+str(ymin_val) 
            stmin_val = timestamp_to_string_no_leading_zeros(tmin_val)  
            stmax_val = timestamp_to_string_no_leading_zeros(tmax_val) 
            stime="'"+stmin_val+"'"+","+"'"+stmax_val+"'"
            if stmin_val==stmax_val:
               stime="'"+stmin_val+"'" 
            self.dlg.labelSEL.setText('Press OK and wait ...')
            self.dlg.figEPlot.setEnabled(False)
            self.dlg.expPLfileB.setEnabled(False)
            self.dlg.Npolarst.setEnabled(False)
            self.dlg.Spolarst.setEnabled(False)
            self.dlg.polarstcm.setEnabled(False)
            self.dlg.label_pst.setEnabled(False)
            self.dlg.coastt.setEnabled(False)
            self.dlg.cross_sel.setEnabled(False) 
            self.dlg.cross_np.setEnabled(False) 
            self.dlg.label_pi.setEnabled(False) 
            self.dlg.cross_cr.setEnabled(False)  
            if COORN==4:
                szet=str(zmin_val)+","+str(zmax_val)
                
            varr=self.dlg.varBox.currentText()
            moper=self.dlg.calc.text() 
            if len(moper)==0:
                moper='*1'
            ffm=self.dlg.filter.text()
            slist_month=self.dlg.sMonths.text() 
            slonn=self.dlg.sXX.text()
            if len(slonn)!=0:
                slon=slonn
                ngeo=1
            slatt=self.dlg.sYY.text()
            if len(slatt)!=0:
                slat=slatt
                ngeo=1
            stimee=self.dlg.sTIME.text()
            if len(stimee)!=0:
                stime=stimee
            # if COORN==4:
                # szett=self.dlg.sZZ.text()
                # if len(szett)!=0:
                    # szet=szett
                    
            s_ds22='ds2.'+varr
            code = compile(s_ds22, "<string>", "eval")
            ds22=eval(code,{'ds2':ds2})   

            # pobranie atrybutow
            atrxx=ds22.attrs
            
           # sss='                         '                        
           # self.dlg.labelSEL.setText(sss)

            smoper='ds22'+moper
            try:
                code = compile(smoper, "<string>", "eval")
                ds22C=eval(code,{'ds22':ds22,'ds2':ds2})
                calc_erflag=False
            except Exception as e:
                ds22C=ds22
                calc_erflag=True
            ds222=ds22C
            ffm = ffm.replace('var', 'ds22C')
            # when varr is 3d
            if len(ds22C.dims)==3:
                COORN=3
                self.dlg.sZZ.setEnabled(False)
                ssz=''
                self.dlg.sZZ.setText(ssz) 
            elif len(ds22C.dims)==4:
                COORN=4
                self.dlg.sZZ.setEnabled(True)
            if COORN==4:
                szett=self.dlg.sZZ.text()
                if len(szett)!=0:
                    szet=szett    
            if len(ffm)>0:
                mfilter=1
            else:
                mfilter=0
                
            if COORN==3:
                stype=stypeDEF(slon,slat,stime)
                sX=l_c[l_ci[0]];sY=l_c[l_ci[1]];sT=l_c[l_ci[2]]

                if mfilter==0:
                        if stype==1:
                            s_ds222=f"ds22C.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=slice({stime}))"
                        elif stype==2:
                            s_ds222=f"ds22C.sel({sX}=slice({slon}),{sY}=slice({slat})).sel({sT}=({stime}),method='nearest')"
                        elif stype==3:
                            s_ds222=f"ds22C.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}))"
                        elif stype==4:
                            s_ds222=f"ds22C.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=({stime}),method='nearest')"
                else:
                        if stype==1:
                            s_ds222=f"ds22C.{ffm}.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=slice({stime}))"
                        elif stype==2:
                            s_ds222=f"ds22C.{ffm}.sel({sX}=slice({slon}),{sY}=slice({slat})).sel({sT}=({stime}),method='nearest')"
                        elif stype==3:
                            s_ds222=f"ds22C.{ffm}.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}))"
                        elif stype==4:
                            s_ds222=f"ds22C.{ffm}.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=({stime}),method='nearest')"    
                    

                try:
                    code = compile(s_ds222, "<string>", "eval")
                    ds222=eval(code,{'ds22C':ds22C,'ds2':ds2})  

                    if len(slist_month)>0 and stype!=2 and stype!=4 and stype!=22 and stype!=44:
                            list_month = tuple(map(int, slist_month.split(',')))
                            s_ds222=f"ds222.sel(time=ds222.time.dt.month.isin([{list_month}]))"
                            code = compile(s_ds222, "<string>", "eval")
                            ds222=eval(code,{'ds222':ds222}) 
    
                    xdd=len(ds222.to_dict()['data'][0])  # brak danych
                    sres=f' {COORN},{stype},{mmask}'
                    if xdd==0:
                        self.dlg.labelSEL.setText('Selection empty')
                        self.dlg.figType.setText('')
                    else:
                        if calc_erflag:
                           sss='Calculation error'
                        else:   
                            sss='Selection successfull '+sres
                            self.dlg.labelSEL.setText(sss)
                        self.dlg.labelssres.setText(sres)   # in extraxt to points
                        # figure
                        if stype==1:
                           self.dlg.figType.setText('Histogram')
                           self.dlg.expMapB.setEnabled(False)
                           self.dlg.expTSfileB.setEnabled(False)
                           self.dlg.exportVPfileB.setEnabled(False)
                           self.dlg.exportCROSfileB.setEnabled(False)
                           self.dlg.Npolarst.setEnabled(True)
                           self.dlg.Spolarst.setEnabled(True)
                           self.dlg.polarstcm.setEnabled(True)
                           self.dlg.label_pst.setEnabled(True)
                           self.dlg.coastt.setEnabled(True)     
                        elif stype==2:
                           self.dlg.figType.setText('Map (raster)') 
                           if mmask==1:
                                self.dlg.expMapB.setEnabled(True)
                           else:
                                self.dlg.expMapB.setEnabled(False)
                           self.dlg.Npolarst.setEnabled(True)
                           self.dlg.Spolarst.setEnabled(True)
                           self.dlg.polarstcm.setEnabled(True)
                           self.dlg.label_pst.setEnabled(True)
                           self.dlg.coastt.setEnabled(True)     
                           self.dlg.expTSfileB.setEnabled(False)
                           self.dlg.exportVPfileB.setEnabled(False)
                           self.dlg.exportCROSfileB.setEnabled(False)
                        elif stype==3:
                           self.dlg.figType.setText('Time series') 
                           self.dlg.expMapB.setEnabled(False)
                           self.dlg.expTSfileB.setEnabled(True)
                           self.dlg.exportVPfileB.setEnabled(False)
                           self.dlg.exportCROSfileB.setEnabled(False)
                    xdd=None        
                except: 
                    self.dlg.labelSEL.setText('Selection failed')
                    self.dlg.figType.setText('')
                    self.dlg.expMapB.setEnabled(False)
                    self.dlg.expTSfileB.setEnabled(False)
                    self.dlg.exportVPfileB.setEnabled(False)
                    self.dlg.exportCROSfileB.setEnabled(False)
                    
            if COORN==4:   
                stype=stypeDEF4(slon,slat,szet,stime)
                sX=l_c[l_ci[0]];sY=l_c[l_ci[1]];sT=l_c[l_ci[2]];sZ=l_c[l_ci[3]]
                
                if mfilter==0:
                    if stype==1:
                        s_ds222=f"ds22C.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=slice({stime}),{sZ}=slice({szet}))"
                    elif stype==11:
                        s_ds222=f"ds22C.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=slice({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==2:
                        s_ds222=f"ds22C.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==22:
                        s_ds222=f"ds22C.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=({stime}),{sZ}=slice({szet}))"
                    elif stype==3:
                        s_ds222=f"ds22C.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==33:
                        s_ds222=f"ds22C.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}),{sZ}=slice({szet}))"        
                    elif stype==4:
                        s_ds222=f"ds22C.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==44:
                        s_ds222=f"ds22C.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=({stime})).sel({sZ}=slice({szet}))"            
                else:
                    if stype==1:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=slice({stime}),{sZ}=slice({szet}))"
                    elif stype==11:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=slice({stime})).sel({sZ}={szet},method='nearest')"        
                    elif stype==2:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==22:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=slice({slon}),{sY}=slice({slat}),{sT}=({stime}),{sZ}=slice({szet}))"
                    elif stype==3:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==33:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}),{sZ}=slice({szet}))"        
                    elif stype==4:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=({stime})).sel({sZ}={szet},method='nearest')"
                    elif stype==44:
                        s_ds222=f"ds22C.{ffm}.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=({stime})).sel({sZ}=slice({szet}))"            
                
                self.dlg.labelSEL.setText('Press OK and wait ...')
                self.dlg.figEPlot.setEnabled(False)
                try:
                        code = compile(s_ds222, "<string>", "eval")
                        ds222=eval(code,{'ds22C':ds22C,'ds22':ds22,'ds2':ds2}) 
                        if len(slist_month)>0 and stype!=2 and stype!=4 and stype!=22 and stype!=44:
                                list_month = tuple(map(int, slist_month.split(',')))
                                s_ds222=f"ds222.sel(time=ds222.time.dt.month.isin([{list_month}]))"
                                code = compile(s_ds222, "<string>", "eval")
                                ds222=eval(code,{'ds222':ds222}) 
                        xdd=len(ds222.to_dict()['data'][0])  # brak danych
                        sres=f' {COORN},{stype},{mmask}'
                        if xdd==0:
                            self.dlg.labelSEL.setText('Selection empty')
                        else:
                            if calc_erflag:
                                    sss='Calculation error'
                            else:   
                                    sss='Selection successfull '+sres                        
                            self.dlg.labelSEL.setText(sss)
                            self.dlg.labelssres.setText(sres)   # in extraxt to points
                            # figure
                            if stype==1:
                               self.dlg.figType.setText('Histogram')
                               self.dlg.expMapB.setEnabled(False)
                               self.dlg.expTSfileB.setEnabled(False)
                               self.dlg.exportVPfileB.setEnabled(False)
                               self.dlg.exportCROSfileB.setEnabled(False)
                            elif stype==2:
                               self.dlg.figType.setText('Map (raster)') 
                               if mmask==1:
                                    self.dlg.expMapB.setEnabled(True)
                               else:
                                    self.dlg.expMapB.setEnabled(False)
                               self.dlg.Npolarst.setEnabled(True)
                               self.dlg.Spolarst.setEnabled(True)
                               self.dlg.polarstcm.setEnabled(True)
                               self.dlg.label_pst.setEnabled(True)
                               self.dlg.coastt.setEnabled(True)
                               self.dlg.expTSfileB.setEnabled(False)
                               self.dlg.exportVPfileB.setEnabled(False)
                               self.dlg.exportCROSfileB.setEnabled(False)
                            elif stype==3:
                               self.dlg.figType.setText('Time series')                             
                               self.dlg.expMapB.setEnabled(False)
                               self.dlg.expTSfileB.setEnabled(True)
                               self.dlg.exportVPfileB.setEnabled(False)
                               self.dlg.exportCROSfileB.setEnabled(False)
                            elif stype==22 or stype==11:
                               self.dlg.figType.setText('Histogram')
                               self.dlg.expMapB.setEnabled(False)
                               self.dlg.expTSfileB.setEnabled(False)
                               self.dlg.exportVPfileB.setEnabled(False)
                               self.dlg.exportCROSfileB.setEnabled(False)
                               if stype==11:
                                   self.dlg.Npolarst.setEnabled(True)
                                   self.dlg.Spolarst.setEnabled(True)
                                   self.dlg.polarstcm.setEnabled(True)
                                   self.dlg.label_pst.setEnabled(True)
                                   self.dlg.coastt.setEnabled(True)     
                            elif stype==33:
                               self.dlg.figType.setText('Depth-time-cross-section')
                               self.dlg.expMapB.setEnabled(False)
                               self.dlg.expTSfileB.setEnabled(False)
                               self.dlg.exportVPfileB.setEnabled(False)
                               self.dlg.exportCROSfileB.setEnabled(True) 
                            elif stype==44:
                               self.dlg.figType.setText('Vertical profile')
                               self.dlg.expMapB.setEnabled(False)
                               self.dlg.expTSfileB.setEnabled(False)
                               self.dlg.exportVPfileB.setEnabled(True)
                               self.dlg.exportCROSfileB.setEnabled(False)                            
                            
                        xdd=None        
                except: 
                        self.dlg.labelSEL.setText('Selection failed')
                        self.dlg.figType.setText('Histogram')
                        self.dlg.expMapB.setEnabled(False)
                        self.dlg.expTSfileB.setEnabled(False)
                        self.dlg.exportVPfileB.setEnabled(False)
                        self.dlg.exportCROSfileB.setEnabled(False)
            # przypisanie atrybutow
            ds222=ds222.assign_attrs(atrxx)
            
            # optuons in Statistics  depending on  mmask, stype and COORN
            if mmask==0:
                self.dlg.SBzs.setEnabled(False)
                self.dlg.SBzsfile.setEnabled(False)
                #self.dlg.SBegfile.setEnabled(False)
                self.dlg.SBzsfileB.setEnabled(False)
                #self.dlg.SBegfileB.setEnabled(False)
            else:
                self.dlg.zoneL.setEnabled(True) 
                if stype==1 or stype==11:
                    self.dlg.SBzs.setEnabled(True)
                    self.dlg.SBzsfile.setEnabled(True)
                    self.dlg.SBzsfileB.setEnabled(True)
            
            if stype==1 or stype==11 : 
                self.dlg.SBss.setEnabled(True)
                self.dlg.SBssfile.setEnabled(True)
                self.dlg.SBssfileB.setEnabled(True)
            
            # stat
            if stype==1 or stype==11 or stype==33:
                self.dlg.statPlotB.setEnabled(True)
            else:
                 self.dlg.statPlotB.setEnabled(False)
            if stype==1 or stype==11:
                self.dlg.ssumPlotB.setEnabled(True)
            else:
                 self.dlg.ssumPlotB.setEnabled(False)     
            if (stype==1 and COORN==4):
                self.dlg.statPlotBB.setEnabled(True)
            self.dlg.statSavefile.setEnabled(False)
            self.dlg.statSavefileB.setEnabled(False)
            self.dlg.stgeofile.setEnabled(False)
            self.dlg.stgeofileB.setEnabled(False)
            self.dlg.stprofile.setEnabled(False)
            self.dlg.stprofileB.setEnabled(False)
            self.dlg.statExp.setEnabled(False)
            # extract
            self.dlg.EXTrun.setEnabled(True)
            # group
            if stype==1 or (stype==11 and COORN==4):
                     self.dlg.GRrun.setEnabled(True) 
            else:
                     self.dlg.GRrun.setEnabled(False) 

                    
                    
        if mflow=='figg':  
            figsize=self.dlg.figSize.text()
            figsize=convert_to_int(figsize, 1, 6, 3)
            sss=str(int(figsize));self.dlg.figSize.setText(sss)
            fasp=self.dlg.figAsp.text()
            fasp=convert_to_int(fasp, 0.2, 6, 2)
            sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=self.dlg.fontSize.text()
            ffont=convert_to_int(ffont, 4, 14, 8)
            sss=str(int(ffont));self.dlg.fontSize.setText(sss)
            fdpi=self.dlg.figDpi.text()
            fdpi=convert_to_int(fdpi, 72, 600, 300)
            sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
            
           
            plt.rcParams.update({'font.size': ffont}) 
                
            if stype==1 or stype==22 or stype==11:
                ds222.plot(size=figsize,aspect=fasp)
                plt.tight_layout()
            if stype==2: 
                if self.dlg.Npolarst.isChecked() or self.dlg.Spolarst.isChecked():
                    ttcm=self.dlg.polarstcm.text()
                    nttcm=convert_to_float(ttcm)
                    if nttcm==999:
                        nttcm=0
                    xmin_valw=float(ds222[l_c[l_ci[0]]].min());xmax_valw=float(ds222[l_c[l_ci[0]]].max())
                    ymin_valw=float(ds222[l_c[l_ci[1]]].min());ymax_valw=float(ds222[l_c[l_ci[1]]].max())
                    fig=plt.figure(figsize=(6,4))
                    if self.dlg.Npolarst.isChecked():
                        ax = plt.axes(projection=ccrs.NorthPolarStereo(central_longitude=nttcm))
                    else:
                        ax = plt.axes(projection=ccrs.SouthPolarStereo(central_longitude=nttcm))
                    ax.set_extent([xmin_valw, xmax_valw, ymin_valw, ymax_valw],crs=ccrs.PlateCarree()) 
                    #ds222.plot.pcolormesh(
                    ds222.plot(
                        ax=ax, transform=ccrs.PlateCarree(), x=l_c[l_ci[0]], y=l_c[l_ci[1]], add_colorbar=True
                    )


                    if self.dlg.coastt.isChecked():
                        ax.add_feature(cfeature.COASTLINE,zorder=1,linewidth=0.8) 
                    plt.tight_layout()                    
                else:   
                    ds222.plot(size=figsize,aspect=fasp)
                    plt.tight_layout()
            if stype==3: 
                ds222.plot(size=figsize,aspect=fasp)
                plt.tight_layout()  
            if stype==33:
                ds222.plot(aspect=fasp,size=figsize,y=sZ,yincrease=False)
                plt.tight_layout() 
            if stype==44:
                ds222.plot(aspect=fasp,size=figsize,y=sZ,yincrease=False)
                plt.tight_layout()
                
            #plt.ioff()
            plt.show()
            #self.dlg.figEPlot.setEnabled(True)
            self.dlg.expPLfileB.setEnabled(True)
        
        if mflow=='figgr':
            figsize=3;sss=str(figsize);self.dlg.figSize.setText(sss)
            fasp=2;sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=8;sss=str(ffont);self.dlg.fontSize.setText(sss)
            fdpi=300;sss=str(fdpi);self.dlg.figDpi.setText(sss)
            
        if mflow=='figgS': 
        
            fdpi=float(self.dlg.figDpi.text())
            plt.rcParams.update({'font.size': ffont})  
            figname=self.dlg.expPLfile.text()
            
            # if stype==1 or stype==22 or stype==11:
                # ds222.plot(size=figsize,aspect=fasp)
                # plt.tight_layout()
            # if stype==2: 
                # ds222.plot(size=figsize,aspect=fasp)
                # plt.tight_layout()
            # if stype==3: 
                # ds222.plot(size=figsize,aspect=fasp)
                # plt.tight_layout()  
            # if stype==33:
                # ds222.plot(aspect=fasp,size=figsize,y=sZ,yincrease=False)
                # plt.tight_layout() 
            # if stype==44:
                # ds222.plot(aspect=fasp,size=figsize,y=sZ,yincrease=False)
                # plt.tight_layout()  
            plt.savefig(figname,dpi=fdpi);
            if (stype==1 or stype==11 or stype==22) and self.dlg.histdata.isChecked():
                # 
                figname2=convert_to_data_csv_path(figname)
                
                # Flatten the data array and convert it to a 1D array
                values = ds22.values.flatten()

                # Exclude NaN values
                values = values[~np.isnan(values)]

                # Determine the number of values to extract (max 10,000 or less if values are fewer)
                num_values_to_extract = min(10000, values.size)

                # Randomly sample values without replacement
                random_values = np.random.choice(values, size=num_values_to_extract, replace=False)

                # Reshape into 100 rows
                rows = np.array_split(random_values, 100)

                # Write to a text file
                with open(figname2, "w") as f:
                    for row in rows:
                        # Join the row values with commas and write to the file
                        f.write(",".join(map(str, row)) + "\n")            
        if mflow=='figgE':
            if stype==2 and mmask==1:

                yy,xx=extract_floats(slat,slon)                       
                fn2=self.dlg.expMap.text()
                if COORN==4:
                    nnp=ds222.to_numpy()[0]
                else:
                    nnp=ds222.to_numpy()
                xy_extent=nnp.shape
                gdal.AllRegister() 
                ds=gdal.Open(fn,gdal.GA_ReadOnly)
                if ds is None:                      
                    pass
                else:    
                    # rozmiar rastra
                    cols=ds.RasterXSize
                    rows=ds.RasterYSize
                    bands=ds.RasterCount
                    #print(cols,rows,bands)
                    # geo transform
                    geotransform=ds.GetGeoTransform()
                    x_topleft=geotransform[0]
                    y_topleft=geotransform[3]
                    xxpix=geotransform[1]
                    yypix=geotransform[5]
                    proj=ds.GetProjection()
                    #print(x_topleft,y_topleft,xxpix,yypix)
                    #print(proj)  
                    np2=np.flipud(nnp)    # obrcenie up-down
                    driver=ds.GetDriver()
                    outraster=driver.Create(fn2,xy_extent[1],xy_extent[0],1,gdal.GDT_Float32)
                    if ngeo==0:
                        outraster.SetGeoTransform(geotransform)
                    else:    
                        outraster.SetGeoTransform( [xx, geotransform[1], 0, yy, 0, geotransform[5] ] )
                    outraster.SetProjection(proj)
                    outBand=None
                    outBand=outraster.GetRasterBand(1)
                    outBand.WriteArray(np2,0,0)
                    outraster=None
                    driver=None               
        
            if stype==3:
                xd=ds222.to_dict()
                timesff=self.dlg.expTSfile.text()
                out_plik=open(timesff,"w")
                sss=f'time,{varr}\n'
                out_plik.write(sss)
                nn=len(xd['data'])
                if nn==1 and stype==4:
                    time=str(xd['coords']['time']['data'])
                    varr=round(float(xd['data'][0][0]),4)
                    #print(time,varr)
                else:    
                    for i in range(nn):
                        time=str(xd['coords']['time']['data'][i])
                        #print(time[:19],',',round(float(xd['data'][i][0][0]),4))
                        var=round(float(xd['data'][i][0][0]),4)
                        sss=f"{time[:19]},{var}\n"
                        out_plik.write(sss)
                out_plik.close()      
                xd=None
                
            if stype==44 :
                xd=ds222.to_dict()
                timesff=self.dlg.exportVPfile.text()
                out_plik=open(timesff,"w")
                sss=f'{sZ},{varr}\n'
                out_plik.write(sss)
                nn=len(xd['data'])
                nd=len(xd['coords'][sZ]['data']) 
                for j in range(nd):   
                                 vard=round(xd['data'][0][j][0][0],4)
                                 zz=round(xd['coords'][sZ]['data'][j],2)
                                 sss=f'{zz},{vard}\n'
                                 #print(sss)
                                 out_plik.write(sss)
                out_plik.close()  
                xd=None
                
            if stype==33 :
                xd=ds222.to_dict()
                timesff=self.dlg.exportCROSfile.text()
                out_plik=open(timesff,"w")
                sss=f'time,{sZ},{varr}\n'
                out_plik.write(sss)
                nn=len(xd['data'])
                nd=len(xd['coords'][sZ]['data']) 
                for i in range(nn):   #nn
                    for j in range(nd):  #nd
                        time=str(xd['coords']['time']['data'][i])
                        zz=round(xd['coords'][sZ]['data'][j],2)
                        vard=round(xd['data'][i][j][0][0],4)
                        #print(time,zz,vard)
                        sss=f'{time},{zz},{vard}\n'
                        out_plik.write(sss)
                out_plik.close()   
                xd=None
                
        if mflow=='ssrun':
            SB1=self.dlg.SBss.isChecked()
            SB2=self.dlg.SBzs.isChecked()
            
            if SB1==1:
               self.dlg.progressBar.setValue(0)
               if stype==1 or stype==11: 
                    statmapff=self.dlg.SBssfile.text()
                    xd=ds222.to_dict()
                    nn=len(list(xd['data']))
                    out_plik=open(statmapff,"w")
                    sss=f'time,mean,min,max,median,std,sum\n'
                    out_plik.write(sss)
                    #print(sss)
                                    
                        
                    procc=0;licznik=0 
                    krok=nn/100                    
                    self.dlg.progressBar.setValue(procc)
                    for i in range(nn):
                        licznik+=1
                        if licznik>=krok:
                           procc+=1
                           self.dlg.progressBar.setValue(procc)
                           licznik=0
                        stime2=str(xd['coords'][l_c[l_ci[2]]]['data'][i])

                        
                        svmean=f"float(ds222.sel({l_c[l_ci[2]]}='{stime2}').mean())"
                        code = compile(svmean, "<string>", "eval")
                        vmean=eval(code,{'ds222':ds222})
                        svmin=f"float(ds222.sel({l_c[l_ci[2]]}='{stime2}').min())"
                        code = compile(svmin, "<string>", "eval")
                        vmin=eval(code,{'ds222':ds222})
                        svmax=f"float(ds222.sel({l_c[l_ci[2]]}='{stime2}').max())"
                        code = compile(svmax, "<string>", "eval")
                        vmax=eval(code,{'ds222':ds222})
                        svmedian=f"float(ds222.sel({l_c[l_ci[2]]}='{stime2}').median())"
                        code = compile(svmedian, "<string>", "eval")
                        vmedian=eval(code,{'ds222':ds222}) 
                        svstd=f"float(ds222.sel({l_c[l_ci[2]]}='{stime2}').std())"
                        code = compile(svstd, "<string>", "eval")
                        vstd=eval(code,{'ds222':ds222})
                        svsum=f"float(ds222.sel({l_c[l_ci[2]]}='{stime2}').sum())"
                        code = compile(svsum, "<string>", "eval")
                        vsum=eval(code,{'ds222':ds222})                        
                        

                        sss=(f'{stime2},{round(vmean,4)},{round(vmin,4)},'
                            f'{round(vmax,4)},{round(vmedian,4)},{round(vstd,4)},'
                            f' {round(vsum,2)}\n'
                            )
                        out_plik.write(sss)
                    out_plik.close()
                    self.dlg.progressBar.setValue(100)
            if SB2==1:

                slist_zone=self.dlg.zoneL.text()
                
                if is_valid_integer_string(slist_zone):
                    list_z = tuple(map(int, slist_zone.split(',')))
                    self.dlg.progressBar.setValue(0)
                    if (stype==1 or stype==11):
   
                        procc=0;licznik=0 
                        krok=len(list_z)/100  
                        statmapff=self.dlg.SBzsfile.text()
                        out_plik=open(statmapff,"w")
                        sss=f'zone,time,mean,min,max,median,std,sum\n'
                        out_plik.write(sss)
                        for i in range(len(list_z)):
                            licznik+=1
                            if licznik>=krok:
                                procc+=1
                                self.dlg.progressBar.setValue(procc)
                                licznik=0
                            iz=int(list_z[i])
                            sZSds222=f'ds222.where(ds222.mask=={iz})' 
                            code = compile(sZSds222, "<string>", "eval")
                            ZSds222=eval(code,{'ds222':ds222}) 
                            xd=ZSds222.to_dict()
                            nn=len(list(xd['data']))
                            #print(sss)
                            for i in range(nn):
                                stime2=str(xd['coords'][l_c[l_ci[2]]]['data'][i])

                                
                                svmean=f"float(ZSds222.sel({l_c[l_ci[2]]}='{stime2}').mean())"
                                code = compile(svmean, "<string>", "eval")
                                vmean=eval(code,{'ZSds222':ZSds222})
                                svmin=f"float(ZSds222.sel({l_c[l_ci[2]]}='{stime2}').min())"
                                code = compile(svmin, "<string>", "eval")
                                vmin=eval(code,{'ZSds222':ZSds222})
                                svmax=f"float(ZSds222.sel({l_c[l_ci[2]]}='{stime2}').max())"
                                code = compile(svmax, "<string>", "eval")
                                vmax=eval(code,{'ZSds222':ZSds222})
                                svmedian=f"float(ZSds222.sel({l_c[l_ci[2]]}='{stime2}').median())"
                                code = compile(svmedian, "<string>", "eval")
                                vmedian=eval(code,{'ZSds222':ZSds222}) 
                                svstd=f"float(ZSds222.sel({l_c[l_ci[2]]}='{stime2}').std())"
                                code = compile(svstd, "<string>", "eval")
                                vstd=eval(code,{'ZSds222':ZSds222})
                                svsum=f"float(ZSds222.sel({l_c[l_ci[2]]}='{stime2}').sum())"
                                code = compile(svsum, "<string>", "eval")
                                vsum=eval(code,{'ZSds222':ZSds222})                                   
                                        
                                
                                sss=(f'{iz},{stime2},{round(vmean,4)},{round(vmin,4)},'
                                    f'{round(vmax,4)},{round(vmedian,4)},{round(vstd,4)},'
                                    f' {round(vsum,2)}\n'
                                    )
                                # if stype==2 or stype==22:
                                #     print(sss)
                                out_plik.write(sss)
                        out_plik.close()
                        self.dlg.progressBar.setValue(100)
                        ZSds222=None
                        
                
        if mflow=="ssumplot":
            plt.rcParams.update({'font.size': ffont}) 
            figsize=self.dlg.figSize.text()
            figsize=convert_to_int(figsize, 1, 6, 3)
            sss=str(int(figsize));self.dlg.figSize.setText(sss)
            fasp=self.dlg.figAsp.text()
            fasp=convert_to_int(fasp, 0.2, 6, 2)
            sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=self.dlg.fontSize.text()
            ffont=convert_to_int(ffont, 4, 14, 8)
            sss=str(int(ffont));self.dlg.fontSize.setText(sss)
            fdpi=self.dlg.figDpi.text()
            fdpi=convert_to_int(fdpi, 72, 600, 300)
            sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
        
        
            timesum=self.dlg.statBox.currentText()

            if timesum!='quantile(0.1)' and timesum!='quantile(0.9)':
                if COORN==3:
                    sds222=f"ds222.{timesum}('{l_c[l_ci[0]]}').{timesum}('{l_c[l_ci[1]]}')"
                else:
                    if stype==1:
                        sds222=f"ds222.{timesum}('{l_c[l_ci[0]]}').{timesum}('{l_c[l_ci[1]]}').{timesum}('{l_c[l_ci[3]]}')"
                    else:
                        sds222=f"ds222.{timesum}('{l_c[l_ci[0]]}').{timesum}('{l_c[l_ci[1]]}')"
            code = compile(sds222, "<string>", "eval")
            ds222ST=eval(code,{'ds222':ds222}) 
            ds222ST.plot(size=figsize,aspect=fasp)
            plt.tight_layout() 
            plt.show()
            self.dlg.statSavefileB.setEnabled(True)
            self.dlg.statSavePlot.setEnabled(True)
            
        if mflow=="stplot":
            plt.rcParams.update({'font.size': ffont}) 
            figsize=self.dlg.figSize.text()
            figsize=convert_to_int(figsize, 1, 6, 3)
            sss=str(int(figsize));self.dlg.figSize.setText(sss)
            fasp=self.dlg.figAsp.text()
            fasp=convert_to_int(fasp, 0.2, 6, 2)
            sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=self.dlg.fontSize.text()
            ffont=convert_to_int(ffont, 4, 14, 8)
            sss=str(int(ffont));self.dlg.fontSize.setText(sss)
            fdpi=self.dlg.figDpi.text()
            fdpi=convert_to_int(fdpi, 72, 600, 300)
            sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
            
            timesum=self.dlg.statBox.currentText()
            if (stype==11 and COORN==4) or (stype==33 and COORN==4) or (stype==1 and COORN==3):
                ds222ST=None
                if timesum=='quantile(0.1)':
                    timesum='quantile'
                    sds222=f"ds222.{timesum}(0.1,dim='{l_c[l_ci[2]]}')"
                elif  timesum=='quantile(0.9)' :
                      timesum='quantile'
                      sds222=f"ds222.{timesum}(0.9,dim='{l_c[l_ci[2]]}')"
                else:
                    sds222=f"ds222.{timesum}(dim='{l_c[l_ci[2]]}')"
                    
                code = compile(sds222, "<string>", "eval")
                ds222ST=eval(code,{'ds222':ds222}) 
                if stype==33:
                    ds222ST.plot(aspect=fasp,size=figsize,y=sZ,yincrease=False)
                    plt.tight_layout() 
                else:
                    if self.dlg.Npolarst.isChecked() or self.dlg.Spolarst.isChecked():
                        ttcm=self.dlg.polarstcm.text()
                        nttcm=convert_to_float(ttcm)
                        if nttcm==999:
                            nttcm=0
                        xmin_valw=float(ds222ST[l_c[l_ci[0]]].min());xmax_valw=float(ds222ST[l_c[l_ci[0]]].max())
                        ymin_valw=float(ds222ST[l_c[l_ci[1]]].min());ymax_valw=float(ds222ST[l_c[l_ci[1]]].max())
                        fig=plt.figure(figsize=(6,4))
                        if self.dlg.Npolarst.isChecked():
                            ax = plt.axes(projection=ccrs.NorthPolarStereo(central_longitude=nttcm))
                        else: 
                            ax = plt.axes(projection=ccrs.SouthPolarStereo(central_longitude=nttcm))
                        ax.set_extent([xmin_valw, xmax_valw, ymin_valw, ymax_valw],crs=ccrs.PlateCarree()) 
                        ds222ST.plot.pcolormesh(
                            ax=ax, transform=ccrs.PlateCarree(), x=l_c[l_ci[0]], y=l_c[l_ci[1]], add_colorbar=True
                        )
                        if self.dlg.coastt.isChecked():
                            ax.add_feature(cfeature.COASTLINE,zorder=1,linewidth=0.8) 
                        plt.tight_layout()
                    else:    
                        ds222ST.plot(size=figsize,aspect=fasp)
                        
                        plt.tight_layout()                     
                if iscross==1:
                    plt.gca().invert_yaxis()
                plt.show()
                self.dlg.statSavefile.setEnabled(True)
                self.dlg.statSavefileB.setEnabled(True)
                self.dlg.statSavePlot.setEnabled(True)
                if (stype==1 or stype==11) and mmask==1:
                    self.dlg.stgeofile.setEnabled(True)
                    self.dlg.stgeofileB.setEnabled(True)
                    self.dlg.statExp.setEnabled(True)
                    self.dlg.stprofile.setEnabled(False)
                    self.dlg.stprofileB.setEnabled(False)
                if stype==33:
                    self.dlg.stgeofile.setEnabled(False)
                    self.dlg.stgeofileB.setEnabled(False)
                    self.dlg.statExp.setEnabled(True)
                    self.dlg.stprofile.setEnabled(True)
                    self.dlg.stprofileB.setEnabled(True)    
                
        if mflow=="stsplot":    
            fdpi=float(self.dlg.figDpi.text())
            plt.rcParams.update({'font.size': ffont})  
            figname=self.dlg.statSavefile.text()
            plt.savefig(figname,dpi=fdpi);
            
        if mflow=="stplotb": 
            plt.rcParams.update({'font.size': ffont}) 
            figsize=self.dlg.figSize.text()
            figsize=convert_to_int(figsize, 1, 6, 3)
            sss=str(int(figsize));self.dlg.figSize.setText(sss)
            fasp=self.dlg.figAsp.text()
            fasp=convert_to_int(fasp, 0.2, 6, 2)
            sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=self.dlg.fontSize.text()
            ffont=convert_to_int(ffont, 4, 14, 8)
            sss=str(int(ffont));self.dlg.fontSize.setText(sss)
            fdpi=self.dlg.figDpi.text()
            fdpi=convert_to_int(fdpi, 72, 600, 300)
            sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
            
            timesum=self.dlg.statBox.currentText()
            self.dlg.progressBar.setValue(0)
            if (stype==1 and COORN==4):
                xd=ds222.to_dict()
                ltz=[]
                nd=len(xd['coords'][sZ]['data']) 
                for j in range(nd):  #nd
                    zz=xd['coords'][sZ]['data'][j]
                    ltz.append(zz)

                ds222ST=None
                ds222ST2=None

                if timesum=='quantile(0.1)':
                    timesum='quantile'
                    sds222=f"ds222.sel({sZ}={ltz[0]}).{timesum}(0.1,dim='{l_c[l_ci[2]]}')"
                elif  timesum=='quantile(0.9)' :
                    timesum='quantile'
                    sds222=f"ds222.sel({sZ}={ltz[0]}).{timesum}(0.9,dim='{l_c[l_ci[2]]}')"
                else:
                    sds222=f"ds222.sel({sZ}={ltz[0]}).{timesum}(dim='{l_c[l_ci[2]]}')"

                code = compile(sds222, "<string>", "eval")
                ds222ST=eval(code,{'ds222':ds222}) 
                procc=0;licznik=0 
                krok=len(ltz)/100       
                for i in range(1,len(ltz)-1):
                    licznik+=1
                    if licznik>=krok:
                        procc+=1
                        self.dlg.progressBar.setValue(procc)
                        licznik=0
                    if timesum=='quantile(0.1)':
                        timesum='quantile'
                        sds222=f"ds222.sel({sZ}={ltz[i+1]}).{timesum}(0.1,dim='{l_c[l_ci[2]]}')"
                    elif  timesum=='quantile(0.9)' :
                        timesum='quantile'
                        sds222=f"ds222.sel({sZ}={ltz[i+1]}).{timesum}(0.9,dim='{l_c[l_ci[2]]}')"
                    else:
                        sds222=f"ds222.sel({sZ}={ltz[i+1]}).{timesum}(dim='{l_c[l_ci[2]]}')"        

                    code = compile(sds222, "<string>", "eval")
                    ds222ST2=eval(code,{'ds222':ds222}) 
                    
                    if timesum=='sum': 
                        ds222ST2=xr.where(ds222ST2==0,np.nan,ds222ST2)
                
                    ds222ST=xr.where(np.isnan(ds222ST2),ds222ST,ds222ST2)
            
                if timesum=='sum': 
                    ds222ST=xr.where(ds222ST==0,np.nan,ds222ST)
                    
                self.dlg.progressBar.setValue(100)   
                
                if self.dlg.Npolarst.isChecked() or self.dlg.Spolarst.isChecked():
                        ttcm=self.dlg.polarstcm.text()
                        nttcm=convert_to_float(ttcm)
                        if nttcm==999:
                            nttcm=0
                        xmin_valw=float(ds222ST[l_c[l_ci[0]]].min());xmax_valw=float(ds222ST[l_c[l_ci[0]]].max())
                        ymin_valw=float(ds222ST[l_c[l_ci[1]]].min());ymax_valw=float(ds222ST[l_c[l_ci[1]]].max())
                        fig=plt.figure(figsize=(6,4))
                        if self.dlg.Npolarst.isChecked():
                            ax = plt.axes(projection=ccrs.NorthPolarStereo(central_longitude=nttcm))
                        else: 
                            ax = plt.axes(projection=ccrs.SouthPolarStereo(central_longitude=nttcm))
                        ax.set_extent([xmin_valw, xmax_valw, ymin_valw, ymax_valw],crs=ccrs.PlateCarree()) 
                        ds222ST.plot.pcolormesh(
                            ax=ax, transform=ccrs.PlateCarree(), x=l_c[l_ci[0]], y=l_c[l_ci[1]], add_colorbar=True
                        )
                        if self.dlg.coastt.isChecked():
                            ax.add_feature(cfeature.COASTLINE,zorder=1,linewidth=0.8) 
                        plt.tight_layout()
                else:                                   
                        ds222ST.plot(size=figsize,aspect=fasp)
                plt.show()
                self.dlg.statSavefile.setEnabled(True)
                self.dlg.statSavefileB.setEnabled(True)
                self.dlg.statSavePlot.setEnabled(True)
                self.dlg.stgeofile.setEnabled(True)
                self.dlg.stgeofileB.setEnabled(True)
                self.dlg.statExp.setEnabled(True)

                ds222ST2=None


        if mflow=="stexp":
            fn2=self.dlg.stgeofile.text()
            if (stype==11 and mmask==1) or (stype==1 and mmask==1):
                # ds222ST   - array 2D; fn - path to mask; fn2 -output raster
                yy,xx=extract_floats(slat,slon) 
                nnp=ds222ST.to_numpy()      
                xy_extent=nnp.shape
                gdal.AllRegister() 
                ds=gdal.Open(fn,gdal.GA_ReadOnly)
                if ds is None:
                    pass
                else:    
                     # rozmiar rastra
                    cols=ds.RasterXSize
                    rows=ds.RasterYSize
                    bands=ds.RasterCount
                    #print(cols,rows,bands)
                    # geo transform
                    geotransform=ds.GetGeoTransform()
                    x_topleft=geotransform[0]
                    y_topleft=geotransform[3]
                    xxpix=geotransform[1]
                    yypix=geotransform[5]
                    proj=ds.GetProjection()
                    #print(x_topleft,y_topleft,xxpix,yypix)
                    #print(proj)  
                    np2=np.flipud(nnp)    # obrcenie up-down
                    if self.dlg.mask_flip.isChecked():
                        np2=nnp
                    driver=ds.GetDriver()
                    outraster=driver.Create(fn2,xy_extent[1],xy_extent[0],1,gdal.GDT_Float32)
                    if ngeo==0:
                        outraster.SetGeoTransform(geotransform)
                    else:    
                        outraster.SetGeoTransform( [xx, geotransform[1], 0, yy, 0, geotransform[5] ] )
                    outraster.SetProjection(proj)
                    outBand=None
                    outBand=outraster.GetRasterBand(1)
                    outBand.WriteArray(np2,0,0)
                    outraster=None
                    driver=None       
        
            if stype==33:
            
                    xd=ds222ST.to_dict()
                    fn2=self.dlg.stprofile.text()
                    out_plik=open(fn2,"w")
                    sss=f'{sZ},{varr}\n'
                    out_plik.write(sss)
                    nn=len(xd['data'])
                    nd=len(xd['coords'][sZ]['data']) 
                    for j in range(nd):   
                                     vard=round(xd['data'][j][0][0],4)
                                     zz=round(xd['coords'][sZ]['data'][j],2)
                                     sss=f'{zz},{vard}\n'
                                     #print(sss)
                                     out_plik.write(sss)
                    out_plik.close() 
                    xd=None
 
        if mflow=="extract":  
                                                                   
                         
            pointff=self.dlg.expointfile.text()
            ekstrpointff=self.dlg.excsvfile.text()
            
            if is_valid_point_shapefile(pointff) and len(ekstrpointff) > 0:
                
            
                if (stype==1 or stype==2) and COORN==3:
                                   
                    driver=ogr.GetDriverByName('ESRI shapefile')
                    dSource=driver.Open(pointff,0)
                    vlayer=dSource.GetLayer()
                    nn=vlayer.GetFeatureCount()
                    out_plik=open(ekstrpointff,"w")
                    sss=f'IDpoint,X,Y,time,{varr}\n'
                    out_plik.write(sss)
                    #print(sss)
                    for i in range(0,nn):
                        pointxy=vlayer.GetFeature(i)
                        id=pointxy.GetFieldAsInteger(0)
                        geometry=pointxy.GetGeometryRef()
                        x=geometry.GetX()
                        y=geometry.GetY()
                        #print(id,x,y)
                        slon=str(x);slat=str(y) 
                        
                        if stype==1:
                            if mfilter==0:
                                        s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}))"
                            else:
                                        s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime})).{ffm}"
                        elif stype==2:
                            if mfilter==0:  
                                     s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest')"
                            else:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').{ffm}"

                        code = compile(s_ds222, "<string>", "eval")
                        ds2222=eval(code,{'ds222':ds222,'ds22C':ds22C}) 

                        xd=ds2222.to_dict()
                        if stype==1:
                            nn=len(xd['data'])   
                            for i in range(nn):
                                    time=str(xd['coords']['time']['data'][i])
                                    vard=round(float(xd['data'][i][0][0]),4)
                                    if not math.isnan(vard):
                                        sss=f'{id},{round(x,4)},{round(y,4)},{time[:19]},{vard}\n'
                                        #print(id,round(x,4),round(y,4),time[:19],',',round(float(xd['data'][i][0][0]),4))
                                        #print(sss)
                                        out_plik.write(sss)
                        elif stype==2: 
                            nn=len(xd['data'])  
                            for i in range(nn):
                                    time=str(xd['coords']['time']['data'])
                                    vard=round(float(xd['data'][0][0]),4)
                                    if not math.isnan(vard):
                                        sss=f'{id},{round(x,4)},{round(y,4)},{time[:19]},{vard}\n'
                                        out_plik.write(sss)
                                        #print(sss)       
                    dSource=None 
                    ds2222=None
                    out_plik.close()

                if (stype==1 or stype==2 or stype==22 or stype==11) and COORN==4:
                    driver=ogr.GetDriverByName('ESRI shapefile')
                    if stype==1 and has_exactly_two_unique_points(pointff) and self.dlg.cross_sel.isChecked():
                        ssnd=self.dlg.cross_np.text()
                        nd=convert_to_int(ssnd,5,500,20)
                        pointffc=pointff[:-4]+'c.shp'
                        while os.path.isfile(pointffc):
                            pointffc=pointffc[:-4]+'c.shp'
                        ndd=int(nd)
                        add_points_on_segment(pointff, ndd, pointffc)
                        dSource=driver.Open(pointffc,0) 
                        self.dlg.cross_cr.setEnabled(True)                         
                    else:
                        dSource=driver.Open(pointff,0)
                        self.dlg.cross_sel.setEnabled(False) 
                        self.dlg.cross_np.setEnabled(False) 
                        self.dlg.label_pi.setEnabled(False) 
                        self.dlg.cross_cr.setEnabled(False)   
                    vlayer=dSource.GetLayer()
                    nn=vlayer.GetFeatureCount()
                    out_plik=open(ekstrpointff,"w")
                    sss=f'IDpoint,X,Y,time,{sZ},{varr}\n'
                    out_plik.write(sss)
                    #print(sss)
                    for i in range(0,nn):
                        pointxy=vlayer.GetFeature(i)
                        id=pointxy.GetFieldAsInteger(0)
                        geometry=pointxy.GetGeometryRef()
                        x=geometry.GetX()
                        y=geometry.GetY()
                        #print(id,x,y)
                        slon=str(x);slat=str(y)

                        
                        if stype==1 :
                            if mfilter==0:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}),{sZ}=slice({szet}))"
                            else:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}),{sZ}=slice({szet})).{ffm}"
                        elif stype==2 or stype==22:
                            if mfilter==0:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest')"
                            else:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').{ffm}"
                        elif stype==11:
                            if mfilter==0:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime}))"
                            else:
                                    s_ds222=f"ds222.sel({sX}=[{slon}],{sY}=[{slat}],method='nearest').sel({sT}=slice({stime})).{ffm}"                    
                        
                        code = compile(s_ds222, "<string>", "eval")
                        ds2222=eval(code,{'ds222':ds222,'ds22C':ds22C})  
                        
                        xd=ds2222.to_dict()
                        
                        if stype==1:
                            nn=len(xd['data'])   
                            nd=len(xd['coords'][sZ]['data']) 
                            for i in range(nn):
                                    time=str(xd['coords']['time']['data'][i])
                                    for j in range(nd):       
                                         vard=round(float(xd['data'][i][j][0][0]),4)
                                         if not math.isnan(vard):  
                                             zz=xd['coords'][sZ]['data'][j]
                                             sss=f'{id},{round(x,4)},{round(y,4)},{time[:19]},{round(zz,2)},{vard}\n'
                                             out_plik.write(sss)
                        elif stype==2: 
                            nn=len(xd['data'])  
                            for i in range(nn):
                                    time=str(xd['coords']['time']['data'])
                                    vard=round(float(xd['data'][0][0][0]),4)
                                    if not math.isnan(vard):
                                        zz=xd['coords'][sZ]['data']
                                        sss=f'{id},{round(x,4)},{round(y,4)},{time[:19]},{round(zz,2)},{vard}\n'
                                        out_plik.write(sss)
                        elif stype==11:                
                            nn=len(xd['data'])   
                            for i in range(nn):
                                    time=str(xd['coords']['time']['data'][i])    
                                    vard=round(float(xd['data'][i][0][0]),4)
                                    if not math.isnan(vard):  
                                             zz=xd['coords'][sZ]['data']
                                             sss=f'{id},{round(x,4)},{round(y,4)},{time[:19]},{round(zz,2)},{vard}\n'
                                             out_plik.write(sss)
                        elif stype==22:
                            nd=len(xd['coords'][sZ]['data']) 
                            time=str(xd['coords']['time']['data'][0])
                            for j in range(nd):       
                                 vard=round(float(xd['data'][0][j][0][0]),4)
                                 if not math.isnan(vard):  
                                     zz=xd['coords'][sZ]['data'][j]
                                     sss=f'{id},{round(x,4)},{round(y,4)},{time[:19]},{round(zz,2)},{vard}\n'
                                     out_plik.write(sss)

                    dSource=None  
                    ds2222=None
                    out_plik.close()

        if mflow=="cross_create":
            
           
            ds222 = create_xarray_dataarray(ekstrpointff,pointffc)     
            ltime=get_time_coordinates_as_strings(ds222)

            self.dlg.cross_time.clear()
            for i in range(len(ltime)):
                self.dlg.cross_time.addItem(ltime[i]) 
                
   
                
                
            
            stype=11;COORN=4;iscross=1
            self.dlg.EXTrun.setEnabled(False)  
            self.dlg.cross_time.setEnabled(True)  
            self.dlg.cross_plot.setEnabled(True) 
            self.dlg.ssumPlotB.setEnabled(False)
            self.dlg.statPlotBB.setEnabled(False)  
            self.dlg.gtsPlot.setEnabled(False)  
        
        if mflow=="cross_pplot":
                
            ltgi=-1;ii=0
            tts=self.dlg.cross_time.currentText()
            for tt in ltime:
               if  tt==tts:
                   ltgi=ii
               ii+=1   
            
            ds222.isel(time=ltgi).plot(size=figsize,aspect=fasp)
            plt.tight_layout() 
            plt.gca().invert_yaxis()
            plt.show()
            self.dlg.cross_plotS.setEnabled(True)  
        
        if mflow=="cross_pplotS":
            plt.rcParams.update({'font.size': ffont}) 
            figsize=self.dlg.figSize.text()
            figsize=convert_to_int(figsize, 1, 6, 3)
            sss=str(int(figsize));self.dlg.figSize.setText(sss)
            fasp=self.dlg.figAsp.text()
            fasp=convert_to_int(fasp, 0.2, 6, 2)
            sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=self.dlg.fontSize.text()
            ffont=convert_to_int(ffont, 4, 14, 8)
            sss=str(int(ffont));self.dlg.fontSize.setText(sss)
            fdpi=self.dlg.figDpi.text()
            fdpi=convert_to_int(fdpi, 72, 600, 300)
            sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
            
            fdpi=float(self.dlg.figDpi.text())
            plt.rcParams.update({'font.size': ffont})  
            figname=self.dlg.expPLcross.text()
            
            
            plt.savefig(figname,dpi=fdpi);
        
        
        if mflow=="group":
            self.dlg.gsubset.setEnabled(True)
            gstat=self.dlg.stat2Box.currentText()
            gtime=self.dlg.periodBox.currentText()
                
            sdsg=f"ds222.groupby('{l_c[l_ci[2]]}.{gtime}').{gstat}()"
            code = compile(sdsg, "<string>", "eval")
            dsg=eval(code,{'ds222':ds222}) 
            
            #  input time periods of groups
            xd=dsg.to_dict()
            nn=len(xd['data'])
            ltg=[]
            for i in range(nn):
                    ltg.append(str(xd['coords'][gtime]['data'][i]))
            self.dlg.gptimeBox.clear()
            for i in range(len(ltg)):
                self.dlg.gptimeBox.addItem(ltg[i]) 
            # activation
            self.dlg.gmapPlot.setEnabled(True)
            self.dlg.gmapsPlot.setEnabled(True)
            if mmask==1 and not(stype==1 and COORN==4):
                self.dlg.gmapExp.setEnabled(True)
            self.dlg.gtsPlot.setEnabled(True)
            self.dlg.gtssPlot.setEnabled(True)

            
        if mflow=="gmap":
            ltgi=-1;ii=0
            tts=self.dlg.gptimeBox.currentText()
            for tt in ltg:
               if  tt==tts:
                   ltgi=ii
               ii+=1
            if ltgi>=0: 
                if self.dlg.Npolarst.isChecked() or self.dlg.Spolarst.isChecked():
                        ttcm=self.dlg.polarstcm.text()
                        nttcm=convert_to_float(ttcm)
                        if nttcm==999:
                            nttcm=0
                        xmin_valw=float(dsg[ltgi][l_c[l_ci[0]]].min());xmax_valw=float(dsg[ltgi][l_c[l_ci[0]]].max())
                        ymin_valw=float(dsg[ltgi][l_c[l_ci[1]]].min());ymax_valw=float(dsg[ltgi][l_c[l_ci[1]]].max())
                        fig=plt.figure(figsize=(6,4))
                        if self.dlg.Npolarst.isChecked():
                            ax = plt.axes(projection=ccrs.NorthPolarStereo(central_longitude=nttcm))
                        else:
                            ax = plt.axes(projection=ccrs.SouthPolarStereo(central_longitude=nttcm))
                        ax.set_extent([xmin_valw, xmax_valw, ymin_valw, ymax_valw],crs=ccrs.PlateCarree()) 
                        dsg[ltgi].plot.pcolormesh(
                            ax=ax, transform=ccrs.PlateCarree(), x=l_c[l_ci[0]], y=l_c[l_ci[1]], add_colorbar=True
                        )
                        if self.dlg.coastt.isChecked():
                            ax.add_feature(cfeature.COASTLINE,zorder=1,linewidth=0.8) 
                        plt.tight_layout() 
                else:        
                        dsg[ltgi].plot(size=figsize,aspect=fasp)
                        plt.tight_layout() 
                if iscross==1:
                    plt.gca().invert_yaxis()        
                plt.show()
                
        if mflow=="gts":
                               
            sdsgg=f"dsg.{gstat}(dim=('{l_c[l_ci[0]]}','{l_c[l_ci[1]]}'))"        
                
            code = compile(sdsgg, "<string>", "eval")
            dsgg=eval(code,{'dsg':dsg}) 

            
            if COORN==3:
                dsgg.plot(size=figsize,aspect=fasp)
            elif COORN==4 and stype==11 and gtime!= "season":
                dsgg.plot(aspect=fasp,size=figsize)
            elif COORN==4 and stype==1 and gtime!= "season":
                dsgg.plot(aspect=fasp,size=figsize,y=sZ,yincrease=False)
            #plt.tight_layout()  
            plt.show()
            self.dlg.gtsExp.setEnabled(True)
            
        if mflow=="gmaps":
            plt.rcParams.update({'font.size': ffont}) 
            figsize=self.dlg.figSize.text()
            figsize=convert_to_int(figsize, 1, 6, 3)
            sss=str(int(figsize));self.dlg.figSize.setText(sss)
            fasp=self.dlg.figAsp.text()
            fasp=convert_to_int(fasp, 0.2, 6, 2)
            sss=str(fasp);self.dlg.figAsp.setText(sss)
            ffont=self.dlg.fontSize.text()
            ffont=convert_to_int(ffont, 4, 14, 8)
            sss=str(int(ffont));self.dlg.fontSize.setText(sss)
            fdpi=self.dlg.figDpi.text()
            fdpi=convert_to_int(fdpi, 72, 600, 300)
            sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
            fdpi=float(self.dlg.figDpi.text())
      
            figname=self.dlg.gmapPlotss.text()
            if len(figname)>0:
                plt.savefig(figname,dpi=fdpi);
                

        if mflow=="gmaptif":
        #  Export map as raster GEOTIF # whole raster only
            fn2=self.dlg.gtifEx.text()
            ltgi=-1;ii=0
            tts=self.dlg.gptimeBox.currentText()
            for tt in ltg:
               if  tt==tts:
                   ltgi=ii
               ii+=1
            if mmask==1 and len(fn2)>0 and ltgi>=0:
                nnp=dsg[ltgi].to_numpy()      
                xy_extent=nnp.shape
                gdal.AllRegister() 
                ds=gdal.Open(fn,gdal.GA_ReadOnly)
                if ds is None:
                    #print('None')
                    pass
                else:    
                    # rozmiar rastra
                    cols=ds.RasterXSize
                    rows=ds.RasterYSize
                    bands=ds.RasterCount
                    #print(cols,rows,bands)
                    # geo transform
                    geotransform=ds.GetGeoTransform()
                    x_topleft=geotransform[0]
                    y_topleft=geotransform[3]
                    xxpix=geotransform[1]
                    yypix=geotransform[5]
                    proj=ds.GetProjection()
                    #print(x_topleft,y_topleft,xxpix,yypix)
                    #print(proj)  
                    np2=np.flipud(nnp)    # obrcenie up-down
                    if self.dlg.mask_flip.isChecked():
                       np2=nnp
                    driver=ds.GetDriver()
                    outraster=driver.Create(fn2,xy_extent[1],xy_extent[0],1,gdal.GDT_Float32)
                    outraster.SetGeoTransform(geotransform)
                    outraster.SetProjection(proj)
                    outBand=None
                    outBand=outraster.GetRasterBand(1)
                    outBand.WriteArray(np2,0,0)
                    outraster=None
                    driver=None
        
        if mflow=="gtss":
                plt.rcParams.update({'font.size': ffont}) 
                figsize=self.dlg.figSize.text()
                figsize=convert_to_int(figsize, 1, 6, 3)
                sss=str(int(figsize));self.dlg.figSize.setText(sss)
                fasp=self.dlg.figAsp.text()
                fasp=convert_to_int(fasp, 0.2, 6, 2)
                sss=str(fasp);self.dlg.figAsp.setText(sss)
                ffont=self.dlg.fontSize.text()
                ffont=convert_to_int(ffont, 4, 14, 8)
                sss=str(int(ffont));self.dlg.fontSize.setText(sss)
                fdpi=self.dlg.figDpi.text()
                fdpi=convert_to_int(fdpi, 72, 600, 300)
                sss=str(int(fdpi));self.dlg.figDpi.setText(sss)
                fdpi=float(self.dlg.figDpi.text())
          
                figname=self.dlg.gtssfile.text()
                if len(figname)>0:
                    plt.savefig(figname,dpi=fdpi);              
              
        if mflow=="gtse":

            if (stype==1 and  COORN==3) or (stype==11 and COORN==4) :
                xd=dsgg.to_dict()
                timesff=self.dlg.gtsefile.text()
                out_plik=open(timesff,"w")
                sss=f'{gtime},{varr}\n'
                #print(sss)
                out_plik.write(sss)
                nn=len(xd['data'])
                 
                for i in range(nn):
                        var=round(xd['data'][i],4)
                        ttime=str(xd['coords'][gtime]['data'][i])
                        var=round(float(xd['data'][i]),4)
                        sss=f"{ttime},{var}\n"
                        #print(sss)
                        out_plik.write(sss)
                out_plik.close()  
            elif stype==1 and COORN==4 :
                xd=dsgg.to_dict()
                timesff=self.dlg.gtsefile.text()
                out_plik=open(timesff,"w")
                sss=f'{gtime},{sZ},{varr}\n'
                out_plik.write(sss)
                nn=len(xd['data'])
                nd=len(xd['coords'][sZ]['data']) 
                for i in range(nn):   #nn
                    for j in range(nd):  #nd
                        time=str(xd['coords'][gtime]['data'][i])
                        zz=round(xd['coords'][sZ]['data'][j],2)
                        vard=round(float(xd['data'][i][j]),4)
                        #print(time,zz,vard)
                        sss=f'{time},{zz},{vard}\n'
                        out_plik.write(sss)
                out_plik.close()   
                

        if mflow=="txtnc":
            directory_to_search = self.dlg.cjdir.text()
            output_text_file = self.dlg.cjnctxt.text()
            list_nc_files_to_txt(directory_to_search, output_text_file)
            if self.dlg.Bsort.isChecked():
                    snc2=output_text_file[:-4]+'_sort.csv'
                    sort_files_by_date(output_text_file, snc2)
            self.dlg.cjaddB.setEnabled(False)
            self.dlg.cjaddallB.setEnabled(False)
            self.dlg.cjclearB.setEnabled(False)
            self.dlg.cjlist.setText('') 
            self.dlg.varBox2.clear()

        if mflow=="clear":
            #timesff=self.dlg.gtsefile.text()
            #tts=self.dlg.gptimeBox.currentText()
            self.dlg.cjlist.setText('') 
            
        if mflow=="addall": 
            sss=''
            for i in range(len(var_list2)):
                if i==0:
                    sss=sss+var_list2[i]
                else:
                    sss=sss+','+var_list2[i]
            sssL=sss.split(',')
            self.dlg.cjlist.setText(sss)
            
        if mflow=="add":  
            sss=self.dlg.cjlist.text()
            cjvar=self.dlg.varBox2.currentText()
            if len(sss)==0:
                sss=sss+cjvar
            else:
                sss=sss+','+cjvar
            sssL=sss.split(',')
            self.dlg.cjlist.setText(sss)
      
        if mflow=="ncjoin":
            self.dlg.progressBar2.setValue(0)
            nc_files = self.dlg.cjnctxt.text()
            out_nc = self.dlg.jncfile.text()
            if self.dlg.mergeBtime.isChecked():
                varlist=sssL
                # reading nc list
                lnc=[]
                in_p=open(nc_files,"r")
                for line in in_p.readlines():
                    sss=line.split('\n')
                    if sss[0]!='':
                        lnc.append(sss[0])
                in_p.close()
                il=len(lnc)
                # sel and concat
                ldataset=[]
                procc=0;licznik=0 
                krok=il/50                    
                self.dlg.progressBar2.setValue(procc)
                for ii in range(il):
                        #print(ii,lnc[ii])
                        dtemp1=xr.open_dataset(lnc[ii])
                        if COORN==4:
                            s_ds33=f"dtemp1[{varlist}].sel({sX}=slice({slon}),{sY}=slice({slat}),{sZ}=slice({szet}))"
                        elif COORN==3:
                            s_ds33=f"dtemp1[{varlist}].sel({sX}=slice({slon}),{sY}=slice({slat}))"
                        licznik+=1
                        if licznik>=krok:
                            procc+=1
                            self.dlg.progressBar2.setValue(procc)
                            licznik=0    
                        code = compile(s_ds33, "<string>", "eval")
                        dtemp1=eval(code,{'dtemp1':dtemp1})
                        ldataset.append(dtemp1)
                dtemp2=xr.concat(ldataset, dim=l_c[l_ci[2]])  

                dtemp2.to_netcdf(out_nc)
                procc=100
                self.dlg.progressBar2.setValue(procc)                    
                dtemp1=None
                dtemp2=None        
            if self.dlg.mergeBvar.isChecked():

                in_p=open(nc_files,"r")
                vlist=[]
                for line in in_p.readlines():
                    sss=line
                    if sss[-1]=="\n":
                        sss=sss[:-1]
                    vlist.append(sss)
                in_p.close()
                procc=0;licznik=0 
                il=len(vlist)
                # sel and concat

                krok=il/50                    
                self.dlg.progressBar2.setValue(procc)
                dslist=[]
                for i in range(len(vlist)):
                  dslist.append(xr.open_dataset(vlist[i]))
                dss=xr.merge(dslist)
                dss.to_netcdf(out_nc)
                procc=100
                self.dlg.progressBar2.setValue(procc)                    
                dss=None
       


        if mflow=="ncsave":
            out_nc = self.dlg.sncfile.text()
            if self.dlg.gsubset.isChecked():
                dsg.to_netcdf(out_nc)  
            else:    
                ds222.to_netcdf(out_nc)
                
        if mflow=="gis1":        
            in_file = self.dlg.gisAdtcs.text()
            in_file_pow = self.dlg.gisAkm2.text()
            out_file = self.dlg.gisAout.text() 

            ncross=read_timecross_to_numpy(in_file)
            row=ncross.shape[0]  


            Pncross=read_timecross_to_numpy(in_file_pow)
            rowP=Pncross.shape[0]

            # depths table (levels) from ncross

            rok1=0;flag=0;nyears=1
            ll=[]
            for i in range(0,row):
                if i==0:
                    rok1=int(ncross[i,0])
                if int(ncross[i,0])!=rok1:
                   flag=1 
                   rok1=ncross[i,0];nyears+=1 
                if flag==0:
                    ll.append(ncross[i,1])

            nlev=len(ll)  # number of levels



            # volume table for each layer   
            volsum=0
            ppll=[]

            wsum=0   # sum of weigts

            for i in range(0,rowP-1):
                    p1=Pncross[i,2];p2=Pncross[i+1,2]
                    h=(ll[i+1]-ll[i])*1e-3
                    #vol=h/3.0*(p1+p2+sqrt(p1+p2)) # vol formula  not used
                    vol=h*p1
                    volsum=volsum+vol;

                    ppll.append(vol)
            wsum=volsum

            # mean calculation using weights
            #print('------------------------------------------')

            ff_result=open(out_file,"w")

            ss=f'area: {Pncross[0,2]:.2f}km2 volume: {volsum:.3f}km3  mean depth:  {volsum/Pncross[0,2]*1e3:.1f}m\n'
            #print(ss)
            ff_result.write(ss)
            ss=f'time,mean\n'
            ff_result.write(ss)
            #print(ss)

            ii=0
            for irok in range(0,nyears):
                swwar=0
                year=ncross[ii,0]
                #print(year)
                for ilev in range(0,nlev-1):
                    if ppll[ilev]>0:
                        if ~np.isnan(ncross[ii,2]):
                            if np.isnan(ncross[ii+1,2]):
                                var=ncross[ii,2]
                            else:    
                                var=0.5*(ncross[ii+1,2]+ncross[ii,2])
                            wwar=var*ppll[ilev] 
                            swwar=wwar+swwar

                    ii+=1
                mwar=swwar/(wsum)
                ii+=1
                ss=f'{int(year):d},{mwar:.5}\n'
                ff_result.write(ss)
                #print(ss)

                #print(int(year),',',round(mwar,5))   
            ff_result.close() 
            
        
        if mflow=="manual":
            pdf_url = "https://github.com/urbanskigis/Xraster/blob/main/Xraster_QGIS_Plugin_user_manual_EN_02.pdf"  # Use an absolute path
            webbrowser.open(pdf_url)  # Open the PDF in the default browser
        
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        #if self.first_start == True:
        #    self.first_start = False
        #    self.dlg = XrasterPlugDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
 
            
